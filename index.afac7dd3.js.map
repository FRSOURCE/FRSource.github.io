{"mappings":"C,A,S,C,C,C,C,C,C,C,C,C,E,I,E,A,a,O,W,W,A,a,O,K,K,A,a,O,O,O,A,a,O,O,O,C,E,E,A,Y,O,C,C,E,E,C,C,E,C,E,E,K,E,C,E,E,A,a,O,Q,A,Y,O,O,O,E,O,O,C,I,C,Q,S,E,C,C,C,E,G,C,C,C,E,C,C,G,C,C,C,E,C,C,I,E,A,Y,O,C,C,E,E,C,C,E,C,G,C,G,E,O,E,E,C,G,G,E,O,E,E,C,G,G,G,A,U,O,E,O,E,G,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,O,C,S,C,E,I,E,C,C,E,C,E,C,E,C,O,A,M,E,E,C,E,E,K,C,C,E,I,E,C,C,E,C,I,E,M,C,G,C,C,E,C,E,C,I,C,E,O,C,E,E,E,O,C,I,C,C,O,C,C,E,C,O,C,S,E,C,E,I,E,E,O,C,G,M,A,C,I,E,C,E,E,E,C,C,E,e,C,C,E,E,M,C,S,C,E,I,C,E,C,E,I,C,M,C,E,I,C,O,C,C,C,E,E,O,C,E,E,K,C,E,E,M,C,E,E,Q,C,S,C,C,C,E,C,C,E,C,C,S,C,C,C,E,E,O,C,C,E,C,E,A,E,O,c,C,E,O,C,I,W,O,C,C,E,A,C,G,C,C,E,C,E,I,I,E,E,E,E,M,C,I,E,C,C,E,E,G,E,C,I,E,E,E,A,C,U,O,S,A,a,O,O,O,O,C,E,Y,O,Q,O,G,E,O,W,O,C,E,C,E,C,M,C,S,C,C,C,C,C,ECAA,EAAQ,oBAA6B,QAAQ,CAAC,EAAQ,oBAAwB,YAAY,CAAC,SAAS,KAAK,KAAK,CAAC,4U,E,C,mB,Q,mB,O,E,C,M,C,S,C,C,C,C,C,ECE/G,IAAI,EAAU,IAAI,GAgBlB,CAAA,EAAO,OAAO,CAAC,QAAQ,CAfvB,SAAkB,CAAO,CAAE,CAAQ,EACjC,IAAK,IAAI,EAAI,EAAG,EAAI,EAAS,MAAM,CAAG,EAAG,GAAK,EAC5C,EAAQ,GAAG,CAAC,CAAQ,CAAC,EAAE,CAAE,CACvB,QAAS,EACT,KAAM,CAAQ,CAAC,EAAI,EAAE,AACvB,EAEJ,EASA,EAAO,OAAO,CAAC,OAAO,CARtB,SAAiB,CAAE,EACjB,IAAI,EAAW,EAAQ,GAAG,CAAC,GAC3B,GAAI,AAAY,MAAZ,EACF,MAAM,AAAI,MAAM,oCAAsC,GAExD,OAAO,IAAI,IAAI,EAAS,IAAI,CAAE,EAAS,OAAO,EAAE,QAAQ,EAC1D,C,E,C,E,C,Q,C,S,C,C,C,C,C,ECfA,IAAI,EAAY,CAAC,EAsBjB,SAAS,EAAW,CAAG,EACrB,MAAQ,AAAA,CAAA,GAAK,CAAA,EAAK,OAAO,CAAC,0EAA2E,MAAQ,GAC/G,CAUA,EAAQ,YAAY,CAjCpB,SAA4B,CAAE,EAC5B,IAAI,EAAQ,CAAS,CAAC,EAAG,CAKzB,OAJK,IACH,EAAQ,AAKZ,WACE,GAAI,CACF,MAAM,AAAI,OACZ,CAAE,MAAO,EAAK,CACZ,IAAI,EAAW,AAAA,CAAA,GAAK,EAAI,KAAI,AAAJ,EAAO,KAAK,CAAC,oEACrC,GAAI,EAGF,OAAO,EAAW,CAAO,CAAC,EAAE,CAEhC,CACA,MAAO,GACT,IAhBI,CAAS,CAAC,EAAG,CAAG,GAEX,CACT,EA2BA,EAAQ,UAAU,CAAG,EACrB,EAAQ,SAAS,CATjB,SAAmB,CAAG,EACpB,IAAI,EAAU,AAAC,CAAA,GAAK,CAAA,EAAK,KAAK,CAAC,iEAC/B,GAAI,CAAC,EACH,MAAM,AAAI,MAAM,oBAElB,OAAO,CAAO,CAAC,EAAE,AACnB,C,E,C,E,C,Q,C,S,C,C,C,C,C,E,I,E,E,kDCjCA,EAAA,+BAEA,EAAA,gBAEA,IAAA,EAAA,EAAA,Y,E,E,c,C,GACA,EAAA,EAAA,eAQC,AAAA,CAAA,cA0BO,EAzBJ,GAAI,CAAC,OAAO,cAAc,CAAE,CACxB,GAAM,CAAE,QAAS,CAAc,CAAE,CAAG,MAAM,EACtC,mBAEJ,CAAA,OAAO,cAAc,CAAG,CAC5B,CAEA,GAAI,CAAC,WAAW,oCAAoC,OAAO,CAAE,CACzD,IAAM,EAAU,SAAS,IAAI,CAAC,gBAAgB,CAAC,kBAE/C,AAAA,CAAA,EAAA,EAAA,OAAQ,AAAR,EAAS,IACL,WACI,IACI,EAAQ,OAAO,CAAC,CAAC,EAAI,IACjB,WAAW,IAAM,EAAG,SAAS,CAAC,GAAG,CAAC,MAAO,IAAM,IAEvD,OAIR,IAAM,EAAO,SAAS,aAAa,CAAgB,kBAEnD,AAAA,CAAA,EAAA,EAAA,kBAAkB,AAAlB,EAAmB,EACvB,CAIA,SAAS,IAAI,CACR,aAAa,CAAoB,iBACjC,gBAAgB,CAAC,QAAS,iBACvB,GAAI,CAAC,EAAmB,CACpB,IAAI,CAAC,QAAQ,CAAG,CAAA,EAChB,IAAM,EAAsB,MAAM,EAC9B,oBACF,KAAK,CAAC,IAAO,IAAI,CAAC,QAAQ,CAAG,CAAA,GAC/B,GAAI,CAAC,EAAqB,OAC1B,EAAoB,IAAI,EAAoB,iBAAiB,CAC7D,MAAM,EAAoB,iBAAiB,CAAC,cAAc,CAE1D,SAAS,IAAI,CACR,aAAa,CAAC,YACd,qBAAqB,CAClB,aACA,EAAkB,OAAO,EAEjC,IAAI,CAAC,QAAQ,CAAG,CAAA,CACpB,CAEA,EAAkB,OAAO,GACnB,EAAkB,IAAI,GACtB,EAAkB,IAAI,EAChC,GAEJ,IAAM,EAAmB,EAAE,CAC3B,SAAS,IAAI,CAAC,gBAAgB,CAAC,oBAAoB,OAAO,CAAC,AAAC,IACxD,IAAM,EAAQ,EAAI,YAAY,CAAC,cAC/B,EAAO,IAAI,CAAC,GACZ,EAAI,gBAAgB,CAAC,QAAS,KAC1B,aAAa,OAAO,CAAC,YAAa,GAClC,EAAO,OAAO,CAAC,AAAC,GACZ,SAAS,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,KAAO,IAE1C,SAAS,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAO,EACvC,EACJ,GAEI,kBAAmB,WACnB,UAAU,aAAa,CAClB,QAAQ,CAAA,EAAA,qBAGR,KAAK,CAAC,AAAC,GACJ,QAAQ,GAAG,CAAC,uCAAyC,GAGrE,CAAA,G,E,C,8B,Q,e,Q,S,Q,c,Q,mB,Q,mB,Q,iB,Q,iD,O,E,C,Q,C,S,C,C,C,C,C,ECpFA,IAAI,EAAW,SAAU,CAAO,EAG9B,IAGI,EAHA,EAAK,OAAO,SAAS,CACrB,EAAS,EAAG,cAAc,CAC1B,EAAiB,OAAO,cAAc,EAAI,SAAU,CAAG,CAAE,CAAG,CAAE,CAAI,EAAI,CAAG,CAAC,EAAI,CAAG,EAAK,KAAK,AAAE,EAE7F,EAAU,AAAkB,YAAlB,OAAO,OAAwB,OAAS,CAAC,EACnD,EAAiB,EAAQ,QAAQ,EAAI,aACrC,EAAsB,EAAQ,aAAa,EAAI,kBAC/C,EAAoB,EAAQ,WAAW,EAAI,gBAE/C,SAAS,EAAO,CAAG,CAAE,CAAG,CAAE,CAAK,EAO7B,OANA,OAAO,cAAc,CAAC,EAAK,EAAK,CAC9B,MAAO,EACP,WAAY,CAAA,EACZ,aAAc,CAAA,EACd,SAAU,CAAA,CACZ,GACO,CAAG,CAAC,EAAI,AACjB,CACA,GAAI,CAEF,EAAO,CAAC,EAAG,GACb,CAAE,MAAO,EAAK,CACZ,EAAS,SAAS,CAAG,CAAE,CAAG,CAAE,CAAK,EAC/B,OAAO,CAAG,CAAC,EAAI,CAAG,CACpB,CACF,CAEA,SAAS,EAAK,CAAO,CAAE,CAAO,CAAE,CAAI,CAAE,CAAW,EAG/C,IAgNuC,EACnC,EAjNA,EAAY,OAAO,MAAM,CAAC,AADT,CAAA,GAAW,EAAQ,SAAS,YAAY,EAAY,EAAU,CAAnF,EAC6C,SAAS,EAOtD,OAFA,EAAe,EAAW,UAAW,CAAE,KAAA,EA2MA,EA/MzB,IAAI,EAAQ,GAAe,EAAE,EAgNvC,EAAQ,EAEL,SAAgB,CAAM,CAAE,CAAG,EAChC,GAAI,IAAU,EACZ,MAAM,AAAI,MAAM,gCAGlB,GAAI,IAAU,EAAmB,CAC/B,GAAI,AAAW,UAAX,EACF,MAAM,EAMR,MAqQG,CAAE,MAAO,EAAW,KAAM,CAAA,CAAK,CApQpC,CAKA,IAHA,EAAQ,MAAM,CAAG,EACjB,EAAQ,GAAG,CAAG,IAED,CACX,IAAI,EAAW,EAAQ,QAAQ,CAC/B,GAAI,EAAU,CACZ,IAAI,EAAiB,AA0D7B,SAAS,EAAoB,CAAQ,CAAE,CAAO,EAC5C,IAAI,EAAa,EAAQ,MAAM,CAC3B,EAAS,EAAS,QAAQ,CAAC,EAAW,CAC1C,GAAI,IAAW,SAIb,EAAQ,QAAQ,CAAG,KAGA,UAAf,GAA0B,EAAS,QAAQ,CAAC,MAAS,GAGvD,EAAQ,MAAM,CAAG,SACjB,EAAQ,GAAG,CAAG,EACd,EAAoB,EAAU,GAE1B,AAAmB,UAAnB,EAAQ,MAAM,GAMD,WAAf,IACF,EAAQ,MAAM,CAAG,QACjB,EAAQ,GAAG,CAAG,AAAI,UAChB,oCAAsC,EAAa,aAN5C,EAYb,IAAI,EAAS,EAAS,EAAQ,EAAS,QAAQ,CAAE,EAAQ,GAAG,EAE5D,GAAI,AAAgB,UAAhB,EAAO,IAAI,CAIb,OAHA,EAAQ,MAAM,CAAG,QACjB,EAAQ,GAAG,CAAG,EAAO,GAAG,CACxB,EAAQ,QAAQ,CAAG,KACZ,EAGT,IAAI,EAAO,EAAO,GAAG,QAErB,AAAM,EAOF,EAAK,IAAI,EAGX,CAAO,CAAC,EAAS,UAAU,CAAC,CAAG,EAAK,KAAK,CAGzC,EAAQ,IAAI,CAAG,EAAS,OAAO,CAQR,WAAnB,EAAQ,MAAM,GAChB,EAAQ,MAAM,CAAG,OACjB,EAAQ,GAAG,CAAG,GAUlB,EAAQ,QAAQ,CAAG,KACZ,GANE,GA3BP,EAAQ,MAAM,CAAG,QACjB,EAAQ,GAAG,CAAG,AAAI,UAAU,oCAC5B,EAAQ,QAAQ,CAAG,KACZ,EA+BX,EAxIiD,EAAU,GACnD,GAAI,EAAgB,CAClB,GAAI,IAAmB,EAAkB,SACzC,OAAO,CACT,CACF,CAEA,GAAI,AAAmB,SAAnB,EAAQ,MAAM,CAGhB,EAAQ,IAAI,CAAG,EAAQ,KAAK,CAAG,EAAQ,GAAG,MAErC,GAAI,AAAmB,UAAnB,EAAQ,MAAM,CAAc,CACrC,GAAI,IAAU,EAEZ,MADA,EAAQ,EACF,EAAQ,GAAG,CAGnB,EAAQ,iBAAiB,CAAC,EAAQ,GAAG,CAEvC,KAA8B,WAAnB,EAAQ,MAAM,EACvB,EAAQ,MAAM,CAAC,SAAU,EAAQ,GAAG,EAGtC,EAAQ,EAER,IAAI,EAAS,EA9P8C,EAAS,EA8P/B,GACrC,GAAI,AAAgB,WAAhB,EAAO,IAAI,CAAe,CAO5B,GAJA,EAAQ,EAAQ,IAAI,CAChB,EA1OiB,iBA6OjB,EAAO,GAAG,GAAK,EACjB,SAGF,MAAO,CACL,MAAO,EAAO,GAAG,CACjB,KAAM,EAAQ,IAAI,AACpB,CAEF,CAA2B,UAAhB,EAAO,IAAI,GACpB,EAAQ,EAGR,EAAQ,MAAM,CAAG,QACjB,EAAQ,GAAG,CAAG,EAAO,GAAG,CAE5B,CACF,EAvRuF,GAEhF,CACT,CAaA,SAAS,EAAS,CAAE,CAAE,CAAG,CAAE,CAAG,EAC5B,GAAI,CACF,MAAO,CAAE,KAAM,SAAU,IAAK,EAAG,IAAI,CAAC,EAAK,EAAK,CAClD,CAAE,MAAO,EAAK,CACZ,MAAO,CAAE,KAAM,QAAS,IAAK,CAAI,CACnC,CACF,CAlBA,EAAQ,IAAI,CAAG,EAoBf,IAAI,EAAyB,iBAEzB,EAAoB,YACpB,EAAoB,YAIpB,EAAmB,CAAC,EAMxB,SAAS,IAAa,CACtB,SAAS,IAAqB,CAC9B,SAAS,IAA8B,CAIvC,IAAI,EAAoB,CAAC,EACzB,EAAO,EAAmB,EAAgB,WACxC,OAAO,IAAI,AACb,GAEA,IAAI,EAAW,OAAO,cAAc,CAChC,EAA0B,GAAY,EAAS,EAAS,EAAO,EAAE,IACjE,GACA,IAA4B,GAC5B,EAAO,IAAI,CAAC,EAAyB,IAGvC,CAAA,EAAoB,CAApB,EAGF,IAAI,EAAK,EAA2B,SAAS,CAC3C,EAAU,SAAS,CAAG,OAAO,MAAM,CAAC,GAgBtC,SAAS,EAAsB,CAAS,EACtC,CAAC,OAAQ,QAAS,SAAS,CAAC,OAAO,CAAC,SAAS,CAAM,EACjD,EAAO,EAAW,EAAQ,SAAS,CAAG,EACpC,OAAO,IAAI,CAAC,OAAO,CAAC,EAAQ,EAC9B,EACF,EACF,CA+BA,SAAS,EAAc,CAAS,CAAE,CAAW,MAgCvC,EAgCJ,EAAe,IAAI,CAAE,UAAW,CAAE,MA9BlC,SAAiB,CAAM,CAAE,CAAG,EAC1B,SAAS,IACP,OAAO,IAAI,EAAY,SAAS,CAAO,CAAE,CAAM,GAC7C,AApCN,SAAS,EAAO,CAAM,CAAE,CAAG,CAAE,CAAO,CAAE,CAAM,EAC1C,IAAI,EAAS,EAAS,CAAS,CAAC,EAAO,CAAE,EAAW,GACpD,GAAI,AAAgB,UAAhB,EAAO,IAAI,CACb,EAAO,EAAO,GAAG,MACZ,CACL,IAAI,EAAS,EAAO,GAAG,CACnB,EAAQ,EAAO,KAAK,QACxB,AAAI,GACA,AAAiB,UAAjB,OAAO,GACP,EAAO,IAAI,CAAC,EAAO,WACd,EAAY,OAAO,CAAC,EAAM,OAAO,EAAE,IAAI,CAAC,SAAS,CAAK,EAC3D,EAAO,OAAQ,EAAO,EAAS,EACjC,EAAG,SAAS,CAAG,EACb,EAAO,QAAS,EAAK,EAAS,EAChC,GAGK,EAAY,OAAO,CAAC,GAAO,IAAI,CAAC,SAAS,CAAS,EAIvD,EAAO,KAAK,CAAG,EACf,EAAQ,EACV,EAAG,SAAS,CAAK,EAGf,OAAO,EAAO,QAAS,EAAO,EAAS,EACzC,EACF,CACF,EAOa,EAAQ,EAAK,EAAS,EAC/B,EACF,CAEA,OAAO,EAaL,EAAkB,EAAgB,IAAI,CACpC,EAGA,GACE,GACR,CAIiD,EACnD,CAgNA,SAAS,EAAa,CAAI,EACxB,IAAI,EAAQ,CAAE,OAAQ,CAAI,CAAC,EAAE,AAAC,CAE1B,CAAA,KAAK,GACP,CAAA,EAAM,QAAQ,CAAG,CAAI,CAAC,EAAE,AAAF,EAGpB,KAAK,IACP,EAAM,UAAU,CAAG,CAAI,CAAC,EAAE,CAC1B,EAAM,QAAQ,CAAG,CAAI,CAAC,EAAE,EAG1B,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,EACvB,CAEA,SAAS,EAAc,CAAK,EAC1B,IAAI,EAAS,EAAM,UAAU,EAAI,CAAC,CAClC,CAAA,EAAO,IAAI,CAAG,SACd,OAAO,EAAO,GAAG,CACjB,EAAM,UAAU,CAAG,CACrB,CAEA,SAAS,EAAQ,CAAW,EAI1B,IAAI,CAAC,UAAU,CAAG,CAAC,CAAE,OAAQ,MAAO,EAAE,CACtC,EAAY,OAAO,CAAC,EAAc,IAAI,EACtC,IAAI,CAAC,KAAK,CAAC,CAAA,EACb,CA8BA,SAAS,EAAO,CAAQ,EACtB,GAAI,AAAY,MAAZ,EAAkB,CACpB,IAAI,EAAiB,CAAQ,CAAC,EAAe,CAC7C,GAAI,EACF,OAAO,EAAe,IAAI,CAAC,GAG7B,GAAI,AAAyB,YAAzB,OAAO,EAAS,IAAI,CACtB,OAAO,EAGT,GAAI,CAAC,MAAM,EAAS,MAAM,EAAG,CAC3B,IAAI,EAAI,GAAI,EAAO,SAAS,IAC1B,KAAO,EAAE,EAAI,EAAS,MAAM,EAC1B,GAAI,EAAO,IAAI,CAAC,EAAU,GAGxB,OAFA,EAAK,KAAK,CAAG,CAAQ,CAAC,EAAE,CACxB,EAAK,IAAI,CAAG,CAAA,EACL,EAOX,OAHA,EAAK,KAAK,CAAG,EACb,EAAK,IAAI,CAAG,CAAA,EAEL,CACT,EAEA,OAAO,EAAK,IAAI,CAAG,CACrB,CACF,CAEA,MAAM,AAAI,UAAU,OAAO,EAAW,mBACxC,QAhaA,EAAkB,SAAS,CAAG,EAC9B,EAAe,EAAI,cAAe,CAAE,MAAO,EAA4B,aAAc,CAAA,CAAK,GAC1F,EACE,EACA,cACA,CAAE,MAAO,EAAmB,aAAc,CAAA,CAAK,GAEjD,EAAkB,WAAW,CAAG,EAC9B,EACA,EACA,qBAaF,EAAQ,mBAAmB,CAAG,SAAS,CAAM,EAC3C,IAAI,EAAO,AAAkB,YAAlB,OAAO,GAAyB,EAAO,WAAW,CAC7D,MAAO,EAAA,GACH,CAAA,IAAS,GAGR,AAAmC,sBAAnC,CAAA,EAAK,WAAW,EAAI,EAAK,IAAG,AAAH,CAAU,CAE1C,EAEA,EAAQ,IAAI,CAAG,SAAS,CAAM,EAQ5B,OAPI,OAAO,cAAc,CACvB,OAAO,cAAc,CAAC,EAAQ,IAE9B,EAAO,SAAS,CAAG,EACnB,EAAO,EAAQ,EAAmB,sBAEpC,EAAO,SAAS,CAAG,OAAO,MAAM,CAAC,GAC1B,CACT,EAMA,EAAQ,KAAK,CAAG,SAAS,CAAG,EAC1B,MAAO,CAAE,QAAS,CAAI,CACxB,EAqEA,EAAsB,EAAc,SAAS,EAC7C,EAAO,EAAc,SAAS,CAAE,EAAqB,WACnD,OAAO,IAAI,AACb,GACA,EAAQ,aAAa,CAAG,EAKxB,EAAQ,KAAK,CAAG,SAAS,CAAO,CAAE,CAAO,CAAE,CAAI,CAAE,CAAW,CAAE,CAAW,EACnD,KAAK,IAArB,GAAwB,CAAA,EAAc,OAA1C,EAEA,IAAI,EAAO,IAAI,EACb,EAAK,EAAS,EAAS,EAAM,GAC7B,GAGF,OAAO,EAAQ,mBAAmB,CAAC,GAC/B,EACA,EAAK,IAAI,GAAG,IAAI,CAAC,SAAS,CAAM,EAC9B,OAAO,EAAO,IAAI,CAAG,EAAO,KAAK,CAAG,EAAK,IAAI,EAC/C,EACN,EAuKA,EAAsB,GAEtB,EAAO,EAAI,EAAmB,aAO9B,EAAO,EAAI,EAAgB,WACzB,OAAO,IAAI,AACb,GAEA,EAAO,EAAI,WAAY,WACrB,MAAO,oBACT,GAiCA,EAAQ,IAAI,CAAG,SAAS,CAAG,EACzB,IAAI,EAAS,OAAO,GAChB,EAAO,EAAE,CACb,IAAK,IAAI,KAAO,EACd,EAAK,IAAI,CAAC,GAMZ,OAJA,EAAK,OAAO,GAIL,SAAS,IACd,KAAO,EAAK,MAAM,EAAE,CAClB,IAAI,EAAM,EAAK,GAAG,GAClB,GAAI,KAAO,EAGT,OAFA,EAAK,KAAK,CAAG,EACb,EAAK,IAAI,CAAG,CAAA,EACL,CAEX,CAMA,OADA,EAAK,IAAI,CAAG,CAAA,EACL,CACT,CACF,EAmCA,EAAQ,MAAM,CAAG,EAMjB,EAAQ,SAAS,CAAG,CAClB,YAAa,EAEb,MAAO,SAAS,CAAa,EAc3B,GAbA,IAAI,CAAC,IAAI,CAAG,EACZ,IAAI,CAAC,IAAI,CAAG,EAGZ,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,KAAK,CAAG,EACzB,IAAI,CAAC,IAAI,CAAG,CAAA,EACZ,IAAI,CAAC,QAAQ,CAAG,KAEhB,IAAI,CAAC,MAAM,CAAG,OACd,IAAI,CAAC,GAAG,CAAG,EAEX,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,GAEpB,CAAC,EACH,IAAK,IAAI,KAAQ,IAAI,CAEI,MAAnB,EAAK,MAAM,CAAC,IACZ,EAAO,IAAI,CAAC,IAAI,CAAE,IAClB,CAAC,MAAM,CAAC,EAAK,KAAK,CAAC,KACrB,CAAA,IAAI,CAAC,EAAK,CAAG,CAHf,CAON,EAEA,KAAM,WACJ,IAAI,CAAC,IAAI,CAAG,CAAA,EAGZ,IAAI,EAAa,AADD,IAAI,CAAC,UAAU,CAAC,EAAE,CACP,UAAU,CACrC,GAAI,AAAoB,UAApB,EAAW,IAAI,CACjB,MAAM,EAAW,GAAG,CAGtB,OAAO,IAAI,CAAC,IAAI,AAClB,EAEA,kBAAmB,SAAS,CAAS,EACnC,GAAI,IAAI,CAAC,IAAI,CACX,MAAM,EAGR,IAAI,EAAU,IAAI,CAClB,SAAS,EAAO,CAAG,CAAE,CAAM,EAYzB,OAXA,EAAO,IAAI,CAAG,QACd,EAAO,GAAG,CAAG,EACb,EAAQ,IAAI,CAAG,EAEX,IAGF,EAAQ,MAAM,CAAG,OACjB,EAAQ,GAAG,CAAG,GAGT,CAAC,CAAE,CACZ,CAEA,IAAK,IAAI,EAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAG,EAAG,GAAK,EAAG,EAAE,EAAG,CACpD,IAAI,EAAQ,IAAI,CAAC,UAAU,CAAC,EAAE,CAC1B,EAAS,EAAM,UAAU,CAE7B,GAAI,AAAiB,SAAjB,EAAM,MAAM,CAId,OAAO,EAAO,OAGhB,GAAI,EAAM,MAAM,EAAI,IAAI,CAAC,IAAI,CAAE,CAC7B,IAAI,EAAW,EAAO,IAAI,CAAC,EAAO,YAC9B,EAAa,EAAO,IAAI,CAAC,EAAO,cAEpC,GAAI,GAAY,EAAY,CAC1B,GAAI,IAAI,CAAC,IAAI,CAAG,EAAM,QAAQ,CAC5B,OAAO,EAAO,EAAM,QAAQ,CAAE,CAAA,GACzB,GAAI,IAAI,CAAC,IAAI,CAAG,EAAM,UAAU,CACrC,OAAO,EAAO,EAAM,UAAU,CAGlC,MAAO,GAAI,EACT,CAAA,GAAI,IAAI,CAAC,IAAI,CAAG,EAAM,QAAQ,CAC5B,OAAO,EAAO,EAAM,QAAQ,CAAE,CAAA,EADhC,MAIK,GAAI,EACT,CAAA,GAAI,IAAI,CAAC,IAAI,CAAG,EAAM,UAAU,CAC9B,OAAO,EAAO,EAAM,UAAU,CADhC,MAKA,MAAM,AAAI,MAAM,yCAEpB,CACF,CACF,EAEA,OAAQ,SAAS,CAAI,CAAE,CAAG,EACxB,IAAK,IAAI,EAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAG,EAAG,GAAK,EAAG,EAAE,EAAG,CACpD,IAAI,EAAQ,IAAI,CAAC,UAAU,CAAC,EAAE,CAC9B,GAAI,EAAM,MAAM,EAAI,IAAI,CAAC,IAAI,EACzB,EAAO,IAAI,CAAC,EAAO,eACnB,IAAI,CAAC,IAAI,CAAG,EAAM,UAAU,CAAE,CAChC,IAAI,EAAe,EACnB,KACF,CACF,CAEI,GACC,CAAA,AAAS,UAAT,GACA,AAAS,aAAT,CAAS,GACV,EAAa,MAAM,EAAI,GACvB,GAAO,EAAa,UAAU,EAGhC,CAAA,EAAe,IAAf,EAGF,IAAI,EAAS,EAAe,EAAa,UAAU,CAAG,CAAC,QAIvD,CAHA,EAAO,IAAI,CAAG,EACd,EAAO,GAAG,CAAG,EAET,IACF,IAAI,CAAC,MAAM,CAAG,OACd,IAAI,CAAC,IAAI,CAAG,EAAa,UAAU,CAC5B,GAGF,IAAI,CAAC,QAAQ,CAAC,EACvB,EAEA,SAAU,SAAS,CAAM,CAAE,CAAQ,EACjC,GAAI,AAAgB,UAAhB,EAAO,IAAI,CACb,MAAM,EAAO,GAAG,CAclB,MAXI,AAAgB,UAAhB,EAAO,IAAI,EACX,AAAgB,aAAhB,EAAO,IAAI,CACb,IAAI,CAAC,IAAI,CAAG,EAAO,GAAG,CACb,AAAgB,WAAhB,EAAO,IAAI,EACpB,IAAI,CAAC,IAAI,CAAG,IAAI,CAAC,GAAG,CAAG,EAAO,GAAG,CACjC,IAAI,CAAC,MAAM,CAAG,SACd,IAAI,CAAC,IAAI,CAAG,OACa,WAAhB,EAAO,IAAI,EAAiB,GACrC,CAAA,IAAI,CAAC,IAAI,CAAG,CADd,EAIO,CACT,EAEA,OAAQ,SAAS,CAAU,EACzB,IAAK,IAAI,EAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAG,EAAG,GAAK,EAAG,EAAE,EAAG,CACpD,IAAI,EAAQ,IAAI,CAAC,UAAU,CAAC,EAAE,CAC9B,GAAI,EAAM,UAAU,GAAK,EAGvB,OAFA,IAAI,CAAC,QAAQ,CAAC,EAAM,UAAU,CAAE,EAAM,QAAQ,EAC9C,EAAc,GACP,CAEX,CACF,EAEA,MAAS,SAAS,CAAM,EACtB,IAAK,IAAI,EAAI,IAAI,CAAC,UAAU,CAAC,MAAM,CAAG,EAAG,GAAK,EAAG,EAAE,EAAG,CACpD,IAAI,EAAQ,IAAI,CAAC,UAAU,CAAC,EAAE,CAC9B,GAAI,EAAM,MAAM,GAAK,EAAQ,CAC3B,IAAI,EAAS,EAAM,UAAU,CAC7B,GAAI,AAAgB,UAAhB,EAAO,IAAI,CAAc,CAC3B,IAAI,EAAS,EAAO,GAAG,CACvB,EAAc,EAChB,CACA,OAAO,CACT,CACF,CAIA,MAAM,AAAI,MAAM,wBAClB,EAEA,cAAe,SAAS,CAAQ,CAAE,CAAU,CAAE,CAAO,EAanD,OAZA,IAAI,CAAC,QAAQ,CAAG,CACd,SAAU,EAAO,GACjB,WAAY,EACZ,QAAS,CACX,EAEoB,SAAhB,IAAI,CAAC,MAAM,EAGb,CAAA,IAAI,CAAC,GAAG,CAAG,CAAX,EAGK,CACT,CACF,EAMO,CAET,EAK+B,EAAO,OAAW,EAGjD,GAAI,CACF,mBAAqB,CACvB,CAAE,MAAO,EAAsB,CAWzB,AAAsB,UAAtB,OAAO,WACT,WAAW,kBAAkB,CAAG,EAEhC,SAAS,IAAK,0BAA0B,EAE5C,C,E,C,E,C,Q,C,W,E,C,E,C,Q,C,S,C,C,C,C,C,MCrvBiB,CAHjB;;EAEE,EACe,EAMH,WAEZ,IAAc,EAAV,EAAM,EAAE,CACR,EAAM,SACN,EAAO,EAAI,eAAe,CAAC,QAAQ,CACnC,EAAmB,mBACnB,EAAU,AAAA,CAAA,EAAO,aAAe,eAAA,EAAiB,IAAI,CAAC,EAAI,UAAU,EAUxE,OAPK,GACL,EAAI,gBAAgB,CAAC,EAAkB,EAAW,WAGhD,IAFA,EAAI,mBAAmB,CAAC,EAAkB,GAC1C,EAAS,EACF,EAAW,EAAI,KAAK,IAAI,GACjC,GAEO,SAAU,CAAE,EACjB,EAAS,WAAW,EAAI,GAAK,EAAI,IAAI,CAAC,EACxC,CAEF,EAxBoC,EAAO,OAAO,CAAG,G,E,C,E,C,M,C,S,C,C,C,C,C,E,I,E,E,kD,E,iB,C,GCSxC,EAAA,MAAA,CAAA,EAAA,qBAAA,IAAA,GAdb,IAAA,EAAA,EAAA,eAEA,IAAM,EAAU,CAAC,EAAY,CAAC,CAAE,EAAY,CAAC,GAAK,KAAK,MAAM,GAAM,CAAA,EAAI,CAAA,EAAK,EAEtE,EAAmB,AAAC,IACtB,IAAM,EAAQ,MAAM,IAAI,CACpB,EAAK,gBAAgB,CAA2B,SAKpD,OAFA,EAAM,IAAI,CAAC,EAAM,aAAa,CAAgB,QAEvC,CACX,EAEa,EAAqB,AAAC,IAC/B,IAAI,EAAkB,GAElB,EAAgB,CAAC,EAAiB,GAAM,CAE5C,CAAa,CAAC,EAAE,CAAC,OAAO,CAAC,AAAC,GAAU,EAAK,KAAK,CAAC,UAAU,CAAG,UAE5D,IAAM,EAAgB,SAAS,aAAa,CAAC,MAC7C,CAAA,EAAc,KAAK,CAAC,KAAK,CAAG,OAC5B,EAAc,KAAK,CAAC,MAAM,CAAG,OAC7B,EAAK,aAAa,CAAE,WAAW,CAAC,GAChC,EAAc,WAAW,CAAC,GAE1B,IAAM,EAAiB,UACnB,IAAI,CACA,CAAA,IAAoB,CAAa,CAAC,EAAE,CAAC,MAAM,CAAG,EAC9C,EAAU,EAAQ,IAAM,MAExB,EAAE,EACF,EAAc,OAAO,CACjB,AAAC,GACI,CAAa,CAAC,EAAgB,CAAC,KAAK,CAAC,UAAU,CAC5C,WAEZ,EAAU,EAAQ,IAAK,MAG3B,IAEA,WAAW,EAAe,IAAI,CAAA,KAAA,GAAQ,EAC1C,EAEM,EAAe,KACjB,AAAA,CAAA,EAAA,EAAA,WAAU,AAAV,EAAY,MAAM,CAAC,EAAe,CAC9B,OAAQ,CACJ,SAAU,EAAQ,IAAK,KACvB,WAAY,CAChB,CACJ,EACJ,EAkBA,WAAW,EAAe,IAAI,CAAA,KAAA,GAAQ,MAflC,IAEA,EAAgB,MAAM,IAAI,CACtB,EAAc,aAAa,CAAE,gBAAgB,CACzC,kBAEN,GAAG,CAAC,AAAC,GAAkB,EAAiB,IAE1C,EAAc,aAAa,CAAE,KAAK,CAAC,KAAK,CACpC,EAAc,aAAa,CAAE,aAAa,CAAE,KAAK,CAAC,KAAK,CAAG,OAC9D,EAAc,aAAa,CAAE,KAAK,CAAC,MAAM,CACrC,EAAc,aAAa,CAAE,aAAa,CAAE,KAAK,CAAC,MAAM,CAAG,OAC/D,EAAc,aAAa,CAAE,KAAK,CAAC,YAAY,CAAG,mBAK1D,C,E,C,Y,Q,iD,O,E,C,M,C,S,C,C,C,C,C,ECxEA,OAAO,cAAc,CAAC,EAAS,aAAc,CAAE,MAAO,CAAA,CAAK,GAC3D,EAAQ,WAAW,CAAG,EAAQ,YAAY,CAAG,KAAK,EAIlD,IAAM,EAAoB,CAAC,EAAW,QAAQ,GACnC,CAAA,CACH,SAAA,EACA,iBAAkB,CAAA,EAClB,aAAc,CAAA,EACd,OAAQ,AAAa,WAAb,EAAwB,CAAE,SAAU,IAAU,WAAY,GAAS,EAAI,CAAE,SAAU,IAAK,WAAY,CAAE,EAC9G,eAAgB,AAAa,WAAb,EAAwB,CAAE,MAAO,GAAK,IAAK,EAAI,EAAI,CAAE,MAAO,EAAG,IAAK,CAAG,EACvF,MAAO,CACH,SAAU,GACV,WAAY,GACZ,WAAY,EAChB,EACA,MAAO,AAAa,UAAb,EAAuB,CAC1B,MAAO,GACP,SAAU,GACV,UAAW,IACX,UAAW,IACX,UAAW,CAAA,CACf,EAAI,CACA,MAAO,EACP,SAAU,GACV,UAAW,IACX,UAAW,IACX,UAAW,CAAA,CACf,EACA,MAAO,CAAA,CACX,CAAA,EAKE,EAAkB,CAAC,EAAS,KAC9B,GAAI,CAAC,EAAQ,cAAc,CACvB,OAAO,EAEX,IAAM,EAAc,EAAQ,cAAc,CAAC,KAAK,CAC1C,EAAY,EAAQ,cAAc,CAAC,GAAG,CAC5C,GAAI,EAAU,GAAe,EAAU,EACnC,OAAO,EAEX,IAAM,EAAa,EAAe,AAAA,CAAA,EAAY,CAAA,EAAe,SAC7D,AAAI,EAAU,EACF,AAAA,CAAA,EAAU,CAAA,EAAgB,CAAA,EAAa,CAAA,EAGvC,AAAA,CAAA,EAAY,CAAA,EAAY,CAAA,EAAY,CAAA,CAEpD,EAIM,EAAkB,CAAC,EAAS,IACvB,AAAC,CAAA,KAAK,MAAM,GAAK,EAAA,EAAM,EAAI,EAAgB,EAAS,GASzD,EAA+B,CAAC,CAAE,UAAA,CAAS,CAAE,UAAA,CAAS,CAAE,SAAA,CAAQ,CAAE,SAAA,CAAQ,CAAE,IAC9E,IAAM,EAAS,KAAK,KAAK,CAAC,KAAK,MAAM,GAAM,CAAA,AAAC,CAAA,EAAY,CAAA,EAAa,IAAM,CAAA,GAAM,AAAY,IAAZ,EAC3E,EAAQ,KAAK,KAAK,CAAC,KAAK,MAAM,GAAM,CAAA,AAAC,CAAA,EAAW,CAAA,EAAY,IAAM,CAAA,GAAM,AAAW,IAAX,EAExE,EAAM,KAAK,KAAK,CAAC,KAAK,MAAM,GAAM,CAAA,IAAM,CAAA,GACxC,EAAO,KAAK,KAAK,CAAC,KAAK,MAAM,GAAM,CAAA,IAAM,CAAA,GACzC,EAAW,CAAC,EAAE,EAAO,EAAM,EAAE,EAAE,EAAI,CAAC,CAAC,CACrC,EAAc,CAAC,EAAE,EAAO,EAAM,EAAE,EAAE,EAAM,EAAO,CAAC,CAAC,CACjD,EAAa,CAAC,EAAE,EAAK,EAAE,EAAE,EAAM,EAAO,CAAC,CAAC,CACxC,EAAU,CAAC,EAAE,EAAK,EAAE,EAAE,EAAI,CAAC,CAAC,CAClC,MAAO,CAAC,QAAQ,EAAE,EAAS,CAAC,EAAE,EAAY,CAAC,EAAE,EAAW,CAAC,EAAE,EAAQ,CAAC,CAAC,AACzE,EAKM,EAA2B,AAAC,IAC9B,IAAM,EAAY,KAAK,KAAK,CAAC,EAAQ,KAAK,CAAC,QAAQ,CAAG,EAAQ,MAAM,CAAC,QAAQ,CAAG,KAAQ,EAClF,EAAQ,EAAE,CAChB,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAW,EAAE,EAAO,CAC5C,GAAI,AAAgD,IAAhD,EAAgB,EAAS,EAAQ,GAAkB,CACnD,EAAM,IAAI,CAAC,CACP,QAAS,IACT,UAAW,OACX,SAAU,OACd,GACA,QACJ,CACA,IAAM,EAAa,AAA8C,GAA9C,EAAgB,EAAS,EAAQ,GAC9C,EAAS,CACX,QAAS,IACT,UAAW,CAAC,YAAY,EAAE,EAAW,MAAM,CAAC,CAC5C,SAAU,EAA6B,CAAE,UAAW,EAAQ,KAAK,CAAC,SAAS,CAAE,UAAW,EAAQ,KAAK,CAAC,SAAS,CAAE,SAAU,EAAG,SAAU,CAAE,EAC9I,CACI,CAAA,EAAQ,KAAK,CAAC,SAAS,EACvB,CAAA,EAAO,MAAM,CAAG,CAAC,WAAW,EAAE,KAAK,KAAK,CAAC,AAA8C,IAA9C,EAAgB,EAAS,EAAQ,IAAkB,IAAI,CAAC,AAAD,EAEpG,EAAM,IAAI,CAAC,EACf,CACA,MAAO,CACH,MAAA,EACA,OAAQ,OAAO,MAAM,CAAC,CAAE,OAAQ,CAAC,MAAM,EAAE,EAAU,YAAY,CAAC,AAAC,EAAG,EAAQ,MAAM,CACtF,CACJ,EAKM,EAA2B,AAAC,GACvB,AAAC,EAAQ,KAAK,CAAU,CAC3B,MAAO,CACH,CAAE,UAAW,WAAY,QAAS,GAAK,EACvC,CAAE,UAAW,CAAC,MAAM,EAAE,EAAQ,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAE,QAAS,GAAK,EAC/D,CACD,OAAQ,OAAO,MAAM,CAAC,OAAO,MAAM,CAAC,CAAC,EAAG,EAAQ,MAAM,EAAG,CAAE,MAAQ,AAAA,CAAA,EAAQ,cAAc,CAAG,EAAQ,cAAc,CAAC,KAAK,CAAG,CAAA,EAAK,EAAQ,MAAM,CAAC,QAAQ,CAAE,OAAQ,aAAc,EACnL,EANwB,KAYtB,EAAoB,AAAC,IACvB,GAAI,CAAC,EAAQ,KAAK,CACd,MAAO,CAAE,MAAO,EAAE,CAAE,OAAQ,CAAC,CAAE,EAEnC,IAAM,EAAY,KAAK,KAAK,CAAC,EAAQ,KAAK,CAAC,QAAQ,CAAG,EAAQ,MAAM,CAAC,QAAQ,CAAG,KAAQ,EAClF,EAAQ,EAAE,CAChB,IAAK,IAAI,EAAQ,EAAG,EAAQ,EAAW,EAAE,EAAO,CAC5C,IAAM,EAAa,EAAgB,EAAS,EAAQ,GAAa,EAAQ,KAAK,CAAC,UAAU,CAAG,IACtF,EAAa,EAAgB,EAAS,EAAQ,GAAa,EAAQ,KAAK,CAAC,UAAU,CAAG,IAC5F,EAAM,IAAI,CAAC,CACP,UAAW,CAAC,YAAY,EAAE,EAAW,EAAE,EAAE,EAAW,IAAI,CAAC,AAC7D,EACJ,CACA,MAAO,CACH,MAAA,EACA,OAAQ,OAAO,MAAM,CAAC,CAAE,OAAQ,CAAC,MAAM,EAAE,EAAU,YAAY,CAAC,AAAC,EAAG,EAAQ,MAAM,CACtF,CACJ,EAIM,EAAiB,AAAC,GAAY,CAChC,EAAkB,GAClB,EAAyB,MACtB,MAAM,IAAI,CAAC,CAAE,OAAQ,EAAQ,KAAK,CAAC,KAAK,AAAC,GAAG,GAAG,CAAC,IAAM,EAAyB,IACrF,CAAC,MAAM,CAAC,AAAA,GAAS,AAAU,OAAV,EAwBlB,CAAA,EAAQ,YAAY,CAhBC,CAAC,GAAG,KAErB,IAAM,EAAW,AAAC,GAAQ,GAAO,AAAe,UAAf,OAAO,EACxC,OAAO,EAAQ,MAAM,CAAC,CAAC,EAAM,KACzB,OAAO,IAAI,CAAC,GACP,OAAO,CAAC,AAAA,IACL,EAAS,CAAI,CAAC,EAAI,GAAK,EAAS,CAAG,CAAC,EAAI,EACxC,CAAI,CAAC,EAAI,CAAG,AAAC,CAAA,EAAG,EAAQ,YAAW,AAAX,EAAc,CAAI,CAAC,EAAI,CAAE,CAAG,CAAC,EAAI,EAEvC,KAAA,IAAb,CAAG,CAAC,EAAI,EACb,CAAA,CAAI,CAAC,EAAI,CAAG,CAAG,CAAC,EAAI,AAAJ,CAExB,GACO,GACR,CAAC,EACR,EAcA,IAAM,EAAuB,CAAC,EAAS,KACnC,IAAI,EAAI,EAER,GAAI,CAAC,EAAQ,gBAAgB,CACzB,MAAO,CACH,UAAW,EACX,gBAAiB,EACjB,SAAU,EAAQ,iBAAiB,AACvC,EAGJ,GAAI,CAAC,EAAQ,OAAO,CAAC,QAAQ,CAAE,CAE3B,IAAM,EAAkB,SAAS,aAAa,CAAC,OAEzC,EAAY,SAAS,aAAa,CAAC,OASzC,OARI,iBAAiB,GAAS,gBAAgB,CAAC,WAAW,KAAK,CAAC,YAC5D,CAAA,EAAU,KAAK,CAAC,OAAO,CAAG,cAD9B,EAIA,EAAU,WAAW,CAAC,GAErB,AAAgC,OAAhC,CAAA,EAAK,EAAQ,aAAY,AAAZ,GAA2B,AAAO,KAAK,IAAZ,GAAyB,EAAG,YAAY,CAAC,EAAW,GAC7F,EAAgB,OAAO,CAAC,GACjB,CACH,UAAA,EACA,gBAAA,EACA,SAAU,CACd,CACJ,CAEA,IAAM,EAAkB,EAAQ,aAAa,CACvC,EAAY,AAAiC,OAAhC,CAAA,EAAK,EAAQ,aAAa,AAAb,GAA2B,AAAO,KAAK,IAAZ,EAAgB,KAAK,EAAI,EAAG,aAAa,CAEpG,KAAO,EAAgB,QAAQ,CAAC,MAAM,CAAG,GACrC,EAAgB,WAAW,CAAC,EAAgB,QAAQ,CAAC,EAAE,EAI3D,OADA,EAAgB,iBAAiB,CAAC,aAAa,GAAG,OAAO,CAAC,AAAA,GAAa,EAAU,MAAM,IAChF,CACH,UAAA,EACA,gBAAA,EACA,SAAU,CACd,CACJ,EAOM,EAAgB,CAAC,EAAS,EAAQ,KACpC,GAAM,CAAE,SAAA,CAAQ,CAAE,UAAA,CAAS,CAAE,gBAAA,CAAe,CAAE,CAAG,EAAqB,EAAS,EAE/E,CAAA,EAAgB,KAAK,CAAC,OAAO,CAAG,OAE5B,EAAQ,YAAY,EACpB,CAAA,EAAU,KAAK,CAAC,QAAQ,CAAG,QAD/B,EAII,EAAQ,IAAI,EACZ,CAAA,EAAS,SAAS,CAAG,EAAQ,IAAI,AAAJ,EAGjC,EAAS,KAAK,CAAC,QAAQ,CAAG,YAE1B,IAAM,EAAY,EAAS,SAAS,CAAC,CAAA,EAErC,CAAA,EAAU,KAAK,CAAC,QAAQ,CAAG,YAC3B,EAAU,KAAK,CAAC,UAAU,CAAG,OAC7B,EAAU,KAAK,CAAC,aAAa,CAAG,OAChC,EAAU,KAAK,CAAC,OAAO,CAAG,IAC1B,IAAK,IAAI,EAAI,EAAG,EAAI,EAAO,MAAM,CAAG,EAAG,EAAE,EAAG,CACxC,IAAM,EAAW,EAAU,SAAS,CAAC,CAAA,GACrC,EAAgB,WAAW,CAAC,EAChC,CAEA,IAAM,EAAc,KAChB,EAAO,OAAO,CAAC,CAAC,EAAO,KACnB,EACK,QAAQ,CAAC,EAAE,CACX,OAAO,CAAC,EAAM,KAAK,CAAE,EAAM,MAAM,CAC1C,EACJ,EACM,EAAa,KACf,EAAO,OAAO,CAAC,CAAC,EAAG,KACf,EACK,QAAQ,CAAC,EAAE,CACX,aAAa,GACb,OAAO,CAAC,AAAA,IACT,EAAU,MAAM,EACpB,EACJ,EACJ,EAKA,OAHA,EAAU,YAAY,CAAG,KACzB,EAAU,YAAY,CAAG,KACzB,EAAU,OAAO,CAAG,KACZ,EAAQ,QAAQ,EACpB,IAAK,SACD,IACA,KACJ,KAAK,QACD,EAAU,YAAY,CAAG,EACzB,EAAU,YAAY,CAAG,EACzB,KACJ,KAAK,QACD,EAAU,OAAO,CAAG,KAAQ,IAAc,GAAe,CAEjE,CAGA,OADA,EAAQ,OAAO,CAAC,QAAQ,CAAG,IACpB,CAAE,UAAA,EAAW,YAAA,EAAa,WAAA,CAAW,CAChD,CAkCA,CAAA,EAAQ,WAAW,CAAG,CAClB,OA7BW,CAAC,EAAe,cAAc,CAAE,EAAc,CAAC,CAAC,IAE3D,IAAM,EAAW,AAAA,CAAA,EAAG,EAAQ,YAAY,AAAZ,EAAc,EAAkB,EAAY,QAAQ,EAAG,GAE/E,EAAW,EAAE,AACb,AAAwB,CAAA,UAAxB,OAAO,EACP,EAAW,MAAM,IAAI,CAAC,SAAS,gBAAgB,CAAC,IAE3C,aAAwB,SAC7B,EAAW,MAAM,IAAI,CAAC,GAEjB,MAAM,OAAO,CAAC,GACnB,EAAW,EAEN,aAAwB,aAC7B,CAAA,EAAW,CAAC,EAAa,AAAA,EAG7B,IAAM,EAAS,EAAe,GAExB,EAAU,EAAS,GAAG,CAAC,AAAA,GAAW,EAAc,EAAS,EAAQ,IAEvE,MAAO,CACH,WAAY,EAAQ,GAAG,CAAC,AAAA,GAAS,EAAM,SAAS,EAChD,YAAa,IAAM,EAAQ,OAAO,CAAC,AAAA,GAAS,EAAM,WAAW,IAC7D,WAAY,IAAM,EAAQ,OAAO,CAAC,AAAA,GAAS,EAAM,UAAU,GAC/D,CACJ,EAGI,eAAA,EACA,kBAAA,CACJ,C,E,C,E,C,M,C,S,C,C,C,C,C,ECrVA,EAAQ,cAAc,CAAG,SAAU,CAAC,EAClC,OAAO,GAAK,EAAE,UAAU,CAAG,EAAI,CAAC,QAAS,CAAC,CAC5C,EAEA,EAAQ,iBAAiB,CAAG,SAAU,CAAC,EACrC,OAAO,cAAc,CAAC,EAAG,aAAc,CAAC,MAAO,CAAA,CAAI,EACrD,EAEA,EAAQ,SAAS,CAAG,SAAU,CAAM,CAAE,CAAI,EAkBxC,OAjBA,OAAO,IAAI,CAAC,GAAQ,OAAO,CAAC,SAAU,CAAG,EAE7B,YAAR,GACA,AAAQ,eAAR,GACA,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAM,IAK7C,OAAO,cAAc,CAAC,EAAM,EAAK,CAC/B,WAAY,CAAA,EACZ,IAAK,WACH,OAAO,CAAM,CAAC,EAAI,AACpB,CACF,EACF,GAEO,CACT,EAEA,EAAQ,MAAM,CAAG,SAAU,CAAI,CAAE,CAAQ,CAAE,CAAG,EAC5C,OAAO,cAAc,CAAC,EAAM,EAAU,CACpC,WAAY,CAAA,EACZ,IAAK,CACP,EACF,C,E,C,E,C,M,C,S,C,C,C,C,C,EClCA,EAAO,OAAO,CAAI,EAAQ,oBAA+B,EAAQ,mBAA6B,OAAO,CAAC,UAAW,IAAI,CAAC,IAAM,EAAO,MAAM,CAAC,IAAI,CAAC,S,E,C,iB,Q,gB,O,E,C,Q,C,S,C,C,C,C,C,ECE/I,IAAI,EAAc,EAAQ,mBAC1B,CAAA,EAAO,OAAO,CAAG,EAAY,SAAU,CAAM,EAC3C,OAAO,IAAI,QAAQ,SAAU,CAAO,CAAE,CAAM,EAG1C,GAAI,EAAE,CAAC,MAAM,CADS,SAAS,oBAAoB,CAAC,WACrB,IAAI,CAAC,SAAyB,CAAM,EACjE,OAAO,EAAO,GAAG,GAAK,CACxB,GAAI,CACF,IACA,MACF,CACA,IAAI,EAAc,SAAS,aAAa,CAAC,OACzC,CAAA,EAAY,IAAI,CAAG,EACnB,EAAY,GAAG,CAAG,UAClB,EAAY,EAAE,CAAG,SACjB,SAAS,IAAI,CAAC,WAAW,CAAC,GAC1B,IAAI,EAAS,SAAS,aAAa,CAAC,SACpC,CAAA,EAAO,KAAK,CAAG,CAAA,EACf,EAAO,IAAI,CAAG,kBACd,EAAO,GAAG,CAAG,EACb,EAAO,OAAO,CAAG,SAAU,CAAC,EAC1B,IAAI,EAAQ,AAAI,UAAU,gDAAgD,MAAM,CAAC,EAAQ,aAAa,MAAM,CAAC,EAAE,OAAO,EACtH,CAAA,EAAO,OAAO,CAAG,EAAO,MAAM,CAAG,KACjC,EAAO,MAAM,GACb,EAAO,EACT,EACA,EAAO,MAAM,CAAG,WACd,EAAO,OAAO,CAAG,EAAO,MAAM,CAAG,KACjC,GACF,EACA,SAAS,oBAAoB,CAAC,OAAO,CAAC,EAAE,CAAC,WAAW,CAAC,EACvD,EACF,E,E,C,mB,O,E,C,Q,C,S,C,C,C,C,C,EChCA,IAAI,EAAgB,CAAC,EACjB,EAAiB,CAAC,EAClB,EAAmB,CAAC,CAWxB,CAAA,EAAO,OAAO,CAAG,SAAU,CAAM,CAAE,CAAI,EACrC,OAAO,SAAU,CAAM,EACrB,IAAI,EAAQ,AAZhB,SAAkB,CAAI,EACpB,OAAQ,GACN,IAAK,UACH,OAAO,CACT,KAAK,WACH,OAAO,CACT,SACE,OAAO,CACX,CACF,EAGyB,UACrB,AAAI,CAAK,CAAC,EAAO,CACR,CAAK,CAAC,EAAO,CAEf,CAAK,CAAC,EAAO,CAAG,EAAO,KAAK,CAAC,KAAM,WAAW,KAAK,CAAC,SAAU,CAAC,EAEpE,MADA,OAAO,CAAK,CAAC,EAAO,CACd,CACR,EACF,CACF,C,E,C,E,C,Q,C,S,C,C,C,C,C,EC1BA,EAAO,OAAO,CAAG,QAAQ,GAAG,CAAC,CAAC,EAAQ,oBAAgC,EAAQ,oBAA6B,OAAO,CAAC,UAAW,EAAQ,oBAA+B,EAAQ,oBAA6B,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC,IAAM,EAAO,MAAM,CAAC,IAAI,CAAC,S,E,C,iB,Q,iB,Q,mB,O,E,C,M,C,S,C,C,C,C,C,ECE5P,IAAI,EAAc,EAAQ,mBAC1B,CAAA,EAAO,OAAO,CAAG,EAAY,SAAU,CAAM,EAC3C,OAAO,IAAI,QAAQ,SAAU,CAAO,CAAE,CAAM,EAG1C,GAAI,EAAE,CAAC,MAAM,CADO,SAAS,oBAAoB,CAAC,SACrB,IAAI,CAAC,SAAyB,CAAI,EAC7D,OAAO,EAAK,IAAI,GAAK,GAAU,EAAK,GAAG,CAAC,OAAO,CAAC,cAAgB,EAClE,GAAI,CACF,IACA,MACF,CACA,IAAI,EAAO,SAAS,aAAa,CAAC,OAClC,CAAA,EAAK,GAAG,CAAG,aACX,EAAK,IAAI,CAAG,EACZ,EAAK,OAAO,CAAG,SAAU,CAAC,EACxB,EAAK,OAAO,CAAG,EAAK,MAAM,CAAG,KAC7B,EAAK,MAAM,GACX,EAAO,EACT,EACA,EAAK,MAAM,CAAG,WACZ,EAAK,OAAO,CAAG,EAAK,MAAM,CAAG,KAC7B,GACF,EACA,SAAS,oBAAoB,CAAC,OAAO,CAAC,EAAE,CAAC,WAAW,CAAC,EACvD,EACF,E,E,C,iB,O,E,C,Q,C,S,C,C,C,C,C,EC3BA,EAAO,OAAO,CAAG,EAAQ,oBAAwB,YAAY,CAAC,SAAW,kB,E,C,iB,O,E,E,C,Q,Q,C,Q","sources":["<anon>","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/runtime-74cf2cc430890980.js","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/helpers/bundle-manifest.js","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/helpers/bundle-url.js","src/index.ts","../../node_modules/.pnpm/regenerator-runtime@0.14.1/node_modules/regenerator-runtime/runtime.js","../../node_modules/.pnpm/domready@1.0.8/node_modules/domready/ready.js","src/logo.ctrl.ts","../../node_modules/.pnpm/powerglitch@2.3.2/node_modules/powerglitch/lib/src/index.js","../../node_modules/.pnpm/@parcel+transformer-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1_/node_modules/@parcel/transformer-js/src/esmodule-helpers.js","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/runtime-9d6efb0bc8f3a888.js","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/helpers/browser/js-loader.js","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/helpers/cacheLoader.js","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/runtime-676fef989b1ab90e.js","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/helpers/browser/css-loader.js","../../node_modules/.pnpm/@parcel+runtime-js@2.12.0_@parcel+core@2.12.0_@swc+helpers@0.5.1__@swc+helpers@0.5.1/node_modules/@parcel/runtime-js/lib/runtime-30343fe193afbb9f.js"],"sourcesContent":["// modules are defined as an array\n// [ module function, map of requires ]\n//\n// map of requires is short require name -> numeric require\n//\n// anything defined in a previous bundle is accessed via the\n// orig method which is the require for previous bundles\n\n(function (modules, entry, mainEntry, parcelRequireName, globalName) {\n  /* eslint-disable no-undef */\n  var globalObject =\n    typeof globalThis !== 'undefined'\n      ? globalThis\n      : typeof self !== 'undefined'\n      ? self\n      : typeof window !== 'undefined'\n      ? window\n      : typeof global !== 'undefined'\n      ? global\n      : {};\n  /* eslint-enable no-undef */\n\n  // Save the require from previous bundle to this closure if any\n  var previousRequire =\n    typeof globalObject[parcelRequireName] === 'function' &&\n    globalObject[parcelRequireName];\n\n  var cache = previousRequire.cache || {};\n  // Do not use `require` to prevent Webpack from trying to bundle this call\n  var nodeRequire =\n    typeof module !== 'undefined' &&\n    typeof module.require === 'function' &&\n    module.require.bind(module);\n\n  function newRequire(name, jumped) {\n    if (!cache[name]) {\n      if (!modules[name]) {\n        // if we cannot find the module within our internal map or\n        // cache jump to the current global require ie. the last bundle\n        // that was added to the page.\n        var currentRequire =\n          typeof globalObject[parcelRequireName] === 'function' &&\n          globalObject[parcelRequireName];\n        if (!jumped && currentRequire) {\n          return currentRequire(name, true);\n        }\n\n        // If there are other bundles on this page the require from the\n        // previous one is saved to 'previousRequire'. Repeat this as\n        // many times as there are bundles until the module is found or\n        // we exhaust the require chain.\n        if (previousRequire) {\n          return previousRequire(name, true);\n        }\n\n        // Try the node require function if it exists.\n        if (nodeRequire && typeof name === 'string') {\n          return nodeRequire(name);\n        }\n\n        var err = new Error(\"Cannot find module '\" + name + \"'\");\n        err.code = 'MODULE_NOT_FOUND';\n        throw err;\n      }\n\n      localRequire.resolve = resolve;\n      localRequire.cache = {};\n\n      var module = (cache[name] = new newRequire.Module(name));\n\n      modules[name][0].call(\n        module.exports,\n        localRequire,\n        module,\n        module.exports,\n        this\n      );\n    }\n\n    return cache[name].exports;\n\n    function localRequire(x) {\n      var res = localRequire.resolve(x);\n      return res === false ? {} : newRequire(res);\n    }\n\n    function resolve(x) {\n      var id = modules[name][1][x];\n      return id != null ? id : x;\n    }\n  }\n\n  function Module(moduleName) {\n    this.id = moduleName;\n    this.bundle = newRequire;\n    this.exports = {};\n  }\n\n  newRequire.isParcelRequire = true;\n  newRequire.Module = Module;\n  newRequire.modules = modules;\n  newRequire.cache = cache;\n  newRequire.parent = previousRequire;\n  newRequire.register = function (id, exports) {\n    modules[id] = [\n      function (require, module) {\n        module.exports = exports;\n      },\n      {},\n    ];\n  };\n\n  Object.defineProperty(newRequire, 'root', {\n    get: function () {\n      return globalObject[parcelRequireName];\n    },\n  });\n\n  globalObject[parcelRequireName] = newRequire;\n\n  for (var i = 0; i < entry.length; i++) {\n    newRequire(entry[i]);\n  }\n\n  if (mainEntry) {\n    // Expose entry point to Node, AMD or browser globals\n    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js\n    var mainExports = newRequire(mainEntry);\n\n    // CommonJS\n    if (typeof exports === 'object' && typeof module !== 'undefined') {\n      module.exports = mainExports;\n\n      // RequireJS\n    } else if (typeof define === 'function' && define.amd) {\n      define(function () {\n        return mainExports;\n      });\n\n      // <script>\n    } else if (globalName) {\n      this[globalName] = mainExports;\n    }\n  }\n})({\"lwVbV\":[function(require,module,exports) {\nrequire(\"6ff563a09988e99a\").register(require(\"58455e3c5efef45c\").getBundleURL(\"9ltx4\"), JSON.parse('[\"9ltx4\",\"index.afac7dd3.js\",\"ivnvI\",\"ResizeObserver.es.b8944159.js\",\"iGomz\",\"contactDialog.cd9f0fae.js\",\"6kmWC\",\"tpl.7f3037e4.html\",\"7IF6M\",\"contactDialog.ca8e93b2.css\",\"g8wR7\",\"serviceWorker.js\",\"8l6DZ\",\"index.19735fb6.css\"]'));\n\n},{\"6ff563a09988e99a\":\"lK2dr\",\"58455e3c5efef45c\":\"6fsuZ\"}],\"lK2dr\":[function(require,module,exports) {\n\"use strict\";\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n    for(var i = 0; i < manifest.length - 1; i += 2)mapping.set(manifest[i], {\n        baseUrl: baseUrl,\n        path: manifest[i + 1]\n    });\n}\nfunction resolve(id) {\n    var resolved = mapping.get(id);\n    if (resolved == null) throw new Error(\"Could not resolve bundle with id \" + id);\n    return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;\n\n},{}],\"6fsuZ\":[function(require,module,exports) {\n\"use strict\";\nvar bundleURL = {};\nfunction getBundleURLCached(id) {\n    var value = bundleURL[id];\n    if (!value) {\n        value = getBundleURL();\n        bundleURL[id] = value;\n    }\n    return value;\n}\nfunction getBundleURL() {\n    try {\n        throw new Error();\n    } catch (err) {\n        var matches = (\"\" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n        if (matches) // The first two stack frames will be this function and getBundleURLCached.\n        // Use the 3rd one, which will be a runtime in the original bundle.\n        return getBaseURL(matches[2]);\n    }\n    return \"/\";\n}\nfunction getBaseURL(url) {\n    return (\"\" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, \"$1\") + \"/\";\n}\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction getOrigin(url) {\n    var matches = (\"\" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n    if (!matches) throw new Error(\"Origin not found\");\n    return matches[0];\n}\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;\n\n},{}],\"8RSWf\":[function(require,module,exports) {\n/// <reference lib=\"dom\" />\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nvar _runtime = require(\"regenerator-runtime/runtime\");\nvar _indexScss = require(\"./index.scss\");\nvar _domready = require(\"domready\");\nvar _domreadyDefault = parcelHelpers.interopDefault(_domready);\nvar _logoCtrl = require(\"./logo.ctrl\");\n(async ()=>{\n    if (!window.ResizeObserver) {\n        const { default: ResizeObserver } = await require(\"3142584a642ccf32\");\n        window.ResizeObserver = ResizeObserver;\n    }\n    if (!matchMedia(\"(prefers-reduced-motion: reduce)\").matches) {\n        const loadEls = document.body.querySelectorAll(\".load-fadeinup\");\n        (0, _domreadyDefault.default)(()=>setTimeout(()=>loadEls.forEach((el, i)=>setTimeout(()=>el.classList.add(\"in\"), 300 * i)), 3500));\n        const logo = document.querySelector(\".icon-logomark\");\n        (0, _logoCtrl.startLogoAnimation)(logo);\n    }\n    let contactDialogCtrl;\n    document.body.querySelector(\".btn--contact\").addEventListener(\"click\", async function() {\n        if (!contactDialogCtrl) {\n            this.disabled = true;\n            const contactDialogModule = await require(\"8c7be74716b631e6\").catch(()=>this.disabled = false);\n            if (!contactDialogModule) return;\n            contactDialogCtrl = new contactDialogModule.ContactDialogCtrl();\n            await contactDialogModule.ContactDialogCtrl.templateLoader;\n            document.body.querySelector(\".content\").insertAdjacentElement(\"afterbegin\", contactDialogCtrl.element);\n            this.disabled = false;\n        }\n        contactDialogCtrl.isShown() ? contactDialogCtrl.hide() : contactDialogCtrl.show();\n    });\n    const themes = [];\n    document.body.querySelectorAll(\".btn[data-theme]\").forEach((btn)=>{\n        const theme = btn.getAttribute(\"data-theme\");\n        themes.push(theme);\n        btn.addEventListener(\"click\", ()=>{\n            localStorage.setItem(\"FRS:theme\", theme);\n            themes.forEach((theme)=>document.body.classList.remove(\"t-\" + theme));\n            document.body.classList.add(\"t-\" + theme);\n        });\n    });\n    if (\"serviceWorker\" in navigator) navigator.serviceWorker.register(require(\"aa35a12cc35072eb\")).catch((err)=>console.log(\"Service worker registration failed: \" + err));\n})();\n\n},{\"regenerator-runtime/runtime\":\"1OTLH\",\"./index.scss\":\"49xYu\",\"domready\":\"5O9Qp\",\"./logo.ctrl\":\"f6Rj7\",\"3142584a642ccf32\":\"j73bc\",\"8c7be74716b631e6\":\"03xZu\",\"aa35a12cc35072eb\":\"6wzql\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"g7f4C\"}],\"1OTLH\":[function(require,module,exports) {\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var runtime = function(exports) {\n    \"use strict\";\n    var Op = Object.prototype;\n    var hasOwn = Op.hasOwnProperty;\n    var defineProperty = Object.defineProperty || function(obj, key, desc) {\n        obj[key] = desc.value;\n    };\n    var undefined; // More compressible than void 0.\n    var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n    var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n    var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n    var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n    function define(obj, key, value) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n        return obj[key];\n    }\n    try {\n        // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n        define({}, \"\");\n    } catch (err) {\n        define = function(obj, key, value) {\n            return obj[key] = value;\n        };\n    }\n    function wrap(innerFn, outerFn, self, tryLocsList) {\n        // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n        var generator = Object.create(protoGenerator.prototype);\n        var context = new Context(tryLocsList || []);\n        // The ._invoke method unifies the implementations of the .next,\n        // .throw, and .return methods.\n        defineProperty(generator, \"_invoke\", {\n            value: makeInvokeMethod(innerFn, self, context)\n        });\n        return generator;\n    }\n    exports.wrap = wrap;\n    // Try/catch helper to minimize deoptimizations. Returns a completion\n    // record like context.tryEntries[i].completion. This interface could\n    // have been (and was previously) designed to take a closure to be\n    // invoked without arguments, but in all the cases we care about we\n    // already have an existing method we want to call, so there's no need\n    // to create a new function object. We can even get away with assuming\n    // the method takes exactly one argument, since that happens to be true\n    // in every case, so we don't have to touch the arguments object. The\n    // only additional allocation required is the completion record, which\n    // has a stable shape and so hopefully should be cheap to allocate.\n    function tryCatch(fn, obj, arg) {\n        try {\n            return {\n                type: \"normal\",\n                arg: fn.call(obj, arg)\n            };\n        } catch (err) {\n            return {\n                type: \"throw\",\n                arg: err\n            };\n        }\n    }\n    var GenStateSuspendedStart = \"suspendedStart\";\n    var GenStateSuspendedYield = \"suspendedYield\";\n    var GenStateExecuting = \"executing\";\n    var GenStateCompleted = \"completed\";\n    // Returning this object from the innerFn has the same effect as\n    // breaking out of the dispatch switch statement.\n    var ContinueSentinel = {};\n    // Dummy constructor functions that we use as the .constructor and\n    // .constructor.prototype properties for functions that return Generator\n    // objects. For full spec compliance, you may wish to configure your\n    // minifier not to mangle the names of these two functions.\n    function Generator() {}\n    function GeneratorFunction() {}\n    function GeneratorFunctionPrototype() {}\n    // This is a polyfill for %IteratorPrototype% for environments that\n    // don't natively support it.\n    var IteratorPrototype = {};\n    define(IteratorPrototype, iteratorSymbol, function() {\n        return this;\n    });\n    var getProto = Object.getPrototypeOf;\n    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n    GeneratorFunction.prototype = GeneratorFunctionPrototype;\n    defineProperty(Gp, \"constructor\", {\n        value: GeneratorFunctionPrototype,\n        configurable: true\n    });\n    defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n        value: GeneratorFunction,\n        configurable: true\n    });\n    GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n    // Helper for defining the .next, .throw, and .return methods of the\n    // Iterator interface in terms of a single ._invoke method.\n    function defineIteratorMethods(prototype) {\n        [\n            \"next\",\n            \"throw\",\n            \"return\"\n        ].forEach(function(method) {\n            define(prototype, method, function(arg) {\n                return this._invoke(method, arg);\n            });\n        });\n    }\n    exports.isGeneratorFunction = function(genFun) {\n        var ctor = typeof genFun === \"function\" && genFun.constructor;\n        return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n    };\n    exports.mark = function(genFun) {\n        if (Object.setPrototypeOf) Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n        else {\n            genFun.__proto__ = GeneratorFunctionPrototype;\n            define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n        }\n        genFun.prototype = Object.create(Gp);\n        return genFun;\n    };\n    // Within the body of any async function, `await x` is transformed to\n    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n    // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n    // meant to be awaited.\n    exports.awrap = function(arg) {\n        return {\n            __await: arg\n        };\n    };\n    function AsyncIterator(generator, PromiseImpl) {\n        function invoke(method, arg, resolve, reject) {\n            var record = tryCatch(generator[method], generator, arg);\n            if (record.type === \"throw\") reject(record.arg);\n            else {\n                var result = record.arg;\n                var value = result.value;\n                if (value && typeof value === \"object\" && hasOwn.call(value, \"__await\")) return PromiseImpl.resolve(value.__await).then(function(value) {\n                    invoke(\"next\", value, resolve, reject);\n                }, function(err) {\n                    invoke(\"throw\", err, resolve, reject);\n                });\n                return PromiseImpl.resolve(value).then(function(unwrapped) {\n                    // When a yielded Promise is resolved, its final value becomes\n                    // the .value of the Promise<{value,done}> result for the\n                    // current iteration.\n                    result.value = unwrapped;\n                    resolve(result);\n                }, function(error) {\n                    // If a rejected Promise was yielded, throw the rejection back\n                    // into the async generator function so it can be handled there.\n                    return invoke(\"throw\", error, resolve, reject);\n                });\n            }\n        }\n        var previousPromise;\n        function enqueue(method, arg) {\n            function callInvokeWithMethodAndArg() {\n                return new PromiseImpl(function(resolve, reject) {\n                    invoke(method, arg, resolve, reject);\n                });\n            }\n            return previousPromise = // If enqueue has been called before, then we want to wait until\n            // all previous Promises have been resolved before calling invoke,\n            // so that results are always delivered in the correct order. If\n            // enqueue has not been called before, then it is important to\n            // call invoke immediately, without waiting on a callback to fire,\n            // so that the async generator function has the opportunity to do\n            // any necessary setup in a predictable way. This predictability\n            // is why the Promise constructor synchronously invokes its\n            // executor callback, and why async functions synchronously\n            // execute code before the first await. Since we implement simple\n            // async functions in terms of async generators, it is especially\n            // important to get this right, even though it requires care.\n            previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later\n            // invocations of the iterator.\n            callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n        }\n        // Define the unified helper method that is used to implement .next,\n        // .throw, and .return (see defineIteratorMethods).\n        defineProperty(this, \"_invoke\", {\n            value: enqueue\n        });\n    }\n    defineIteratorMethods(AsyncIterator.prototype);\n    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {\n        return this;\n    });\n    exports.AsyncIterator = AsyncIterator;\n    // Note that simple async functions are implemented on top of\n    // AsyncIterator objects; they just return a Promise for the value of\n    // the final result produced by the iterator.\n    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n        if (PromiseImpl === void 0) PromiseImpl = Promise;\n        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n        return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.\n         : iter.next().then(function(result) {\n            return result.done ? result.value : iter.next();\n        });\n    };\n    function makeInvokeMethod(innerFn, self, context) {\n        var state = GenStateSuspendedStart;\n        return function invoke(method, arg) {\n            if (state === GenStateExecuting) throw new Error(\"Generator is already running\");\n            if (state === GenStateCompleted) {\n                if (method === \"throw\") throw arg;\n                // Be forgiving, per GeneratorResume behavior specified since ES2015:\n                // ES2015 spec, step 3: https://262.ecma-international.org/6.0/#sec-generatorresume\n                // Latest spec, step 2: https://tc39.es/ecma262/#sec-generatorresume\n                return doneResult();\n            }\n            context.method = method;\n            context.arg = arg;\n            while(true){\n                var delegate = context.delegate;\n                if (delegate) {\n                    var delegateResult = maybeInvokeDelegate(delegate, context);\n                    if (delegateResult) {\n                        if (delegateResult === ContinueSentinel) continue;\n                        return delegateResult;\n                    }\n                }\n                if (context.method === \"next\") // Setting context._sent for legacy support of Babel's\n                // function.sent implementation.\n                context.sent = context._sent = context.arg;\n                else if (context.method === \"throw\") {\n                    if (state === GenStateSuspendedStart) {\n                        state = GenStateCompleted;\n                        throw context.arg;\n                    }\n                    context.dispatchException(context.arg);\n                } else if (context.method === \"return\") context.abrupt(\"return\", context.arg);\n                state = GenStateExecuting;\n                var record = tryCatch(innerFn, self, context);\n                if (record.type === \"normal\") {\n                    // If an exception is thrown from innerFn, we leave state ===\n                    // GenStateExecuting and loop back for another invocation.\n                    state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n                    if (record.arg === ContinueSentinel) continue;\n                    return {\n                        value: record.arg,\n                        done: context.done\n                    };\n                } else if (record.type === \"throw\") {\n                    state = GenStateCompleted;\n                    // Dispatch the exception by looping back around to the\n                    // context.dispatchException(context.arg) call above.\n                    context.method = \"throw\";\n                    context.arg = record.arg;\n                }\n            }\n        };\n    }\n    // Call delegate.iterator[context.method](context.arg) and handle the\n    // result, either by returning a { value, done } result from the\n    // delegate iterator, or by modifying context.method and context.arg,\n    // setting context.delegate to null, and returning the ContinueSentinel.\n    function maybeInvokeDelegate(delegate, context) {\n        var methodName = context.method;\n        var method = delegate.iterator[methodName];\n        if (method === undefined) {\n            // A .throw or .return when the delegate iterator has no .throw\n            // method, or a missing .next method, always terminate the\n            // yield* loop.\n            context.delegate = null;\n            // Note: [\"return\"] must be used for ES3 parsing compatibility.\n            if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n                // If the delegate iterator has a return method, give it a\n                // chance to clean up.\n                context.method = \"return\";\n                context.arg = undefined;\n                maybeInvokeDelegate(delegate, context);\n                if (context.method === \"throw\") // If maybeInvokeDelegate(context) changed context.method from\n                // \"return\" to \"throw\", let that override the TypeError below.\n                return ContinueSentinel;\n            }\n            if (methodName !== \"return\") {\n                context.method = \"throw\";\n                context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\");\n            }\n            return ContinueSentinel;\n        }\n        var record = tryCatch(method, delegate.iterator, context.arg);\n        if (record.type === \"throw\") {\n            context.method = \"throw\";\n            context.arg = record.arg;\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        var info = record.arg;\n        if (!info) {\n            context.method = \"throw\";\n            context.arg = new TypeError(\"iterator result is not an object\");\n            context.delegate = null;\n            return ContinueSentinel;\n        }\n        if (info.done) {\n            // Assign the result of the finished delegate to the temporary\n            // variable specified by delegate.resultName (see delegateYield).\n            context[delegate.resultName] = info.value;\n            // Resume execution at the desired location (see delegateYield).\n            context.next = delegate.nextLoc;\n            // If context.method was \"throw\" but the delegate handled the\n            // exception, let the outer generator proceed normally. If\n            // context.method was \"next\", forget context.arg since it has been\n            // \"consumed\" by the delegate iterator. If context.method was\n            // \"return\", allow the original .return call to continue in the\n            // outer generator.\n            if (context.method !== \"return\") {\n                context.method = \"next\";\n                context.arg = undefined;\n            }\n        } else // Re-yield the result returned by the delegate method.\n        return info;\n        // The delegate iterator is finished, so forget it and continue with\n        // the outer generator.\n        context.delegate = null;\n        return ContinueSentinel;\n    }\n    // Define Generator.prototype.{next,throw,return} in terms of the\n    // unified ._invoke helper method.\n    defineIteratorMethods(Gp);\n    define(Gp, toStringTagSymbol, \"Generator\");\n    // A Generator should always return itself as the iterator object when the\n    // @@iterator function is called on it. Some browsers' implementations of the\n    // iterator prototype chain incorrectly implement this, causing the Generator\n    // object to not be returned from this call. This ensures that doesn't happen.\n    // See https://github.com/facebook/regenerator/issues/274 for more details.\n    define(Gp, iteratorSymbol, function() {\n        return this;\n    });\n    define(Gp, \"toString\", function() {\n        return \"[object Generator]\";\n    });\n    function pushTryEntry(locs) {\n        var entry = {\n            tryLoc: locs[0]\n        };\n        if (1 in locs) entry.catchLoc = locs[1];\n        if (2 in locs) {\n            entry.finallyLoc = locs[2];\n            entry.afterLoc = locs[3];\n        }\n        this.tryEntries.push(entry);\n    }\n    function resetTryEntry(entry) {\n        var record = entry.completion || {};\n        record.type = \"normal\";\n        delete record.arg;\n        entry.completion = record;\n    }\n    function Context(tryLocsList) {\n        // The root entry object (effectively a try statement without a catch\n        // or a finally block) gives us a place to store values thrown from\n        // locations where there is no enclosing try statement.\n        this.tryEntries = [\n            {\n                tryLoc: \"root\"\n            }\n        ];\n        tryLocsList.forEach(pushTryEntry, this);\n        this.reset(true);\n    }\n    exports.keys = function(val) {\n        var object = Object(val);\n        var keys = [];\n        for(var key in object)keys.push(key);\n        keys.reverse();\n        // Rather than returning an object with a next method, we keep\n        // things simple and return the next function itself.\n        return function next() {\n            while(keys.length){\n                var key = keys.pop();\n                if (key in object) {\n                    next.value = key;\n                    next.done = false;\n                    return next;\n                }\n            }\n            // To avoid creating an additional object, we just hang the .value\n            // and .done properties off the next function object itself. This\n            // also ensures that the minifier will not anonymize the function.\n            next.done = true;\n            return next;\n        };\n    };\n    function values(iterable) {\n        if (iterable != null) {\n            var iteratorMethod = iterable[iteratorSymbol];\n            if (iteratorMethod) return iteratorMethod.call(iterable);\n            if (typeof iterable.next === \"function\") return iterable;\n            if (!isNaN(iterable.length)) {\n                var i = -1, next = function next() {\n                    while(++i < iterable.length)if (hasOwn.call(iterable, i)) {\n                        next.value = iterable[i];\n                        next.done = false;\n                        return next;\n                    }\n                    next.value = undefined;\n                    next.done = true;\n                    return next;\n                };\n                return next.next = next;\n            }\n        }\n        throw new TypeError(typeof iterable + \" is not iterable\");\n    }\n    exports.values = values;\n    function doneResult() {\n        return {\n            value: undefined,\n            done: true\n        };\n    }\n    Context.prototype = {\n        constructor: Context,\n        reset: function(skipTempReset) {\n            this.prev = 0;\n            this.next = 0;\n            // Resetting context._sent for legacy support of Babel's\n            // function.sent implementation.\n            this.sent = this._sent = undefined;\n            this.done = false;\n            this.delegate = null;\n            this.method = \"next\";\n            this.arg = undefined;\n            this.tryEntries.forEach(resetTryEntry);\n            if (!skipTempReset) {\n                for(var name in this)// Not sure about the optimal order of these conditions:\n                if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) this[name] = undefined;\n            }\n        },\n        stop: function() {\n            this.done = true;\n            var rootEntry = this.tryEntries[0];\n            var rootRecord = rootEntry.completion;\n            if (rootRecord.type === \"throw\") throw rootRecord.arg;\n            return this.rval;\n        },\n        dispatchException: function(exception) {\n            if (this.done) throw exception;\n            var context = this;\n            function handle(loc, caught) {\n                record.type = \"throw\";\n                record.arg = exception;\n                context.next = loc;\n                if (caught) {\n                    // If the dispatched exception was caught by a catch block,\n                    // then let that catch block handle the exception normally.\n                    context.method = \"next\";\n                    context.arg = undefined;\n                }\n                return !!caught;\n            }\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                var record = entry.completion;\n                if (entry.tryLoc === \"root\") // Exception thrown outside of any try block that could handle\n                // it, so set the completion value of the entire function to\n                // throw the exception.\n                return handle(\"end\");\n                if (entry.tryLoc <= this.prev) {\n                    var hasCatch = hasOwn.call(entry, \"catchLoc\");\n                    var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n                    if (hasCatch && hasFinally) {\n                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);\n                        else if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n                    } else if (hasCatch) {\n                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, true);\n                    } else if (hasFinally) {\n                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n                    } else throw new Error(\"try statement without catch or finally\");\n                }\n            }\n        },\n        abrupt: function(type, arg) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n                    var finallyEntry = entry;\n                    break;\n                }\n            }\n            if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) // Ignore the finally entry if control is not jumping to a\n            // location outside the try/catch block.\n            finallyEntry = null;\n            var record = finallyEntry ? finallyEntry.completion : {};\n            record.type = type;\n            record.arg = arg;\n            if (finallyEntry) {\n                this.method = \"next\";\n                this.next = finallyEntry.finallyLoc;\n                return ContinueSentinel;\n            }\n            return this.complete(record);\n        },\n        complete: function(record, afterLoc) {\n            if (record.type === \"throw\") throw record.arg;\n            if (record.type === \"break\" || record.type === \"continue\") this.next = record.arg;\n            else if (record.type === \"return\") {\n                this.rval = this.arg = record.arg;\n                this.method = \"return\";\n                this.next = \"end\";\n            } else if (record.type === \"normal\" && afterLoc) this.next = afterLoc;\n            return ContinueSentinel;\n        },\n        finish: function(finallyLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.finallyLoc === finallyLoc) {\n                    this.complete(entry.completion, entry.afterLoc);\n                    resetTryEntry(entry);\n                    return ContinueSentinel;\n                }\n            }\n        },\n        \"catch\": function(tryLoc) {\n            for(var i = this.tryEntries.length - 1; i >= 0; --i){\n                var entry = this.tryEntries[i];\n                if (entry.tryLoc === tryLoc) {\n                    var record = entry.completion;\n                    if (record.type === \"throw\") {\n                        var thrown = record.arg;\n                        resetTryEntry(entry);\n                    }\n                    return thrown;\n                }\n            }\n            // The context.catch method must only be called with a location\n            // argument that corresponds to a known catch block.\n            throw new Error(\"illegal catch attempt\");\n        },\n        delegateYield: function(iterable, resultName, nextLoc) {\n            this.delegate = {\n                iterator: values(iterable),\n                resultName: resultName,\n                nextLoc: nextLoc\n            };\n            if (this.method === \"next\") // Deliberately forget the last sent value so that we don't\n            // accidentally pass it on to the delegate.\n            this.arg = undefined;\n            return ContinueSentinel;\n        }\n    };\n    // Regardless of whether this script is executing as a CommonJS module\n    // or not, return the runtime object so that we can declare the variable\n    // regeneratorRuntime in the outer scope, which allows this module to be\n    // injected easily by `bin/regenerator --include-runtime script.js`.\n    return exports;\n}(// If this script is executing as a CommonJS module, use module.exports\n// as the regeneratorRuntime namespace. Otherwise create a new empty\n// object. Either way, the resulting object will be used to initialize\n// the regeneratorRuntime variable at the top of this file.\n(0, module.exports));\ntry {\n    regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n    // This module should not be running in strict mode, so the above\n    // assignment should always work unless something is misconfigured. Just\n    // in case runtime.js accidentally runs in strict mode, in modern engines\n    // we can explicitly access globalThis. In older engines we can escape\n    // strict mode using a global Function call. This could conceivably fail\n    // if a Content Security Policy forbids using Function, but in that case\n    // the proper solution is to fix the accidental strict mode problem. If\n    // you've misconfigured your bundler to force strict mode and applied a\n    // CSP to forbid Function, and you're not willing to fix either of those\n    // problems, please detail your unique predicament in a GitHub issue.\n    if (typeof globalThis === \"object\") globalThis.regeneratorRuntime = runtime;\n    else Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n\n},{}],\"49xYu\":[function() {},{}],\"5O9Qp\":[function(require,module,exports) {\n/*!\n  * domready (c) Dustin Diaz 2014 - License MIT\n  */ !function(name, definition) {\n    module.exports = definition();\n}(\"domready\", function() {\n    var fns = [], listener, doc = document, hack = doc.documentElement.doScroll, domContentLoaded = \"DOMContentLoaded\", loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState);\n    if (!loaded) doc.addEventListener(domContentLoaded, listener = function() {\n        doc.removeEventListener(domContentLoaded, listener);\n        loaded = 1;\n        while(listener = fns.shift())listener();\n    });\n    return function(fn) {\n        loaded ? setTimeout(fn, 0) : fns.push(fn);\n    };\n});\n\n},{}],\"f6Rj7\":[function(require,module,exports) {\nvar parcelHelpers = require(\"@parcel/transformer-js/src/esmodule-helpers.js\");\nparcelHelpers.defineInteropFlag(exports);\nparcelHelpers.export(exports, \"startLogoAnimation\", ()=>startLogoAnimation);\nvar _powerglitch = require(\"powerglitch\");\nconst randInt = (a = 0, b = 1)=>Math.random() * (b - a) + a;\nconst getItemsToReveal = (logo)=>{\n    const paths = Array.from(logo.querySelectorAll(\"path\"));\n    paths.push(logo.querySelector(\"use\"));\n    return paths;\n};\nconst startLogoAnimation = (logo)=>{\n    let lastVisibleItem = -1;\n    let itemsToReveal = [\n        getItemsToReveal(logo)\n    ];\n    itemsToReveal[0].forEach((item)=>item.style.visibility = \"hidden\");\n    const glitchWrapper = document.createElement(\"div\");\n    glitchWrapper.style.width = \"100%\";\n    glitchWrapper.style.height = \"100%\";\n    logo.parentElement.appendChild(glitchWrapper);\n    glitchWrapper.appendChild(logo);\n    const progressReveal = async ()=>{\n        let timeout;\n        if (lastVisibleItem === itemsToReveal[0].length - 1) timeout = randInt(1000, 6000);\n        else {\n            ++lastVisibleItem;\n            itemsToReveal.forEach((glitchElement)=>glitchElement[lastVisibleItem].style.visibility = \"visible\");\n            timeout = randInt(300, 700);\n        }\n        reinitGlitch();\n        setTimeout(progressReveal.bind(undefined), timeout);\n    };\n    const reinitGlitch = ()=>{\n        (0, _powerglitch.PowerGlitch).glitch(glitchWrapper, {\n            timing: {\n                duration: randInt(300, 2000),\n                iterations: 1\n            }\n        });\n    };\n    const initGlitch = ()=>{\n        reinitGlitch();\n        itemsToReveal = Array.from(glitchWrapper.parentElement.querySelectorAll(\"svg[role=img]\")).map((glitchElement)=>getItemsToReveal(glitchElement));\n        glitchWrapper.parentElement.style.width = glitchWrapper.parentElement.parentElement.style.width = \"100%\";\n        glitchWrapper.parentElement.style.height = glitchWrapper.parentElement.parentElement.style.height = \"100%\";\n        glitchWrapper.parentElement.style.gridTemplate = \"50% 50% / 50% 50%\";\n    };\n    setTimeout(progressReveal.bind(undefined), 2500); // starting timeout\n    initGlitch();\n};\n\n},{\"powerglitch\":\"ziK3M\",\"@parcel/transformer-js/src/esmodule-helpers.js\":\"g7f4C\"}],\"ziK3M\":[function(require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.PowerGlitch = exports.mergeOptions = void 0;\n/**\n * Get best-looking default options for most elements for a given playMode.\n */ const getDefaultOptions = (playMode = \"always\")=>{\n    return {\n        playMode,\n        createContainers: true,\n        hideOverflow: false,\n        timing: playMode === \"always\" ? {\n            duration: 2000,\n            iterations: Infinity\n        } : {\n            duration: 250,\n            iterations: 1\n        },\n        glitchTimeSpan: playMode === \"always\" ? {\n            start: 0.5,\n            end: 0.7\n        } : {\n            start: 0,\n            end: 1\n        },\n        shake: {\n            velocity: 15,\n            amplitudeX: 0.2,\n            amplitudeY: 0.2\n        },\n        slice: playMode === \"click\" ? {\n            count: 15,\n            velocity: 20,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true\n        } : {\n            count: 6,\n            velocity: 15,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true\n        },\n        pulse: false\n    };\n};\n/**\n * Glitch factor function, returns a value between 0 and 1 telling how much the animation should glitch at a given stepPct.\n */ const getGlitchFactor = (options, stepPct)=>{\n    if (!options.glitchTimeSpan) return 1;\n    const glitchStart = options.glitchTimeSpan.start;\n    const glitchEnd = options.glitchTimeSpan.end;\n    if (stepPct < glitchStart || stepPct > glitchEnd) return 0;\n    const glitchPeak = glitchStart + (glitchEnd - glitchStart) / 2;\n    if (stepPct < glitchPeak) return (stepPct - glitchStart) / (glitchPeak - glitchStart);\n    else return (glitchEnd - stepPct) / (glitchEnd - glitchPeak);\n};\n/**\n * Get a random value between -1 and 1, which biases towards the center if the animation should not glitch at the given `stepPct` moment.\n */ const getGlitchRandom = (options, stepPct)=>{\n    return (Math.random() - .5) * 2 * getGlitchFactor(options, stepPct);\n};\n/**\n * Get a random rectangle values in % to glitch. Percent values are between 0 and 100. Returns the rectangle as a CSS polygon.\n * @param minHeight Minimum height of the rectangle in percent, between 0 and 1.\n * @param maxHeight Maximum height of the rectangle in percent, between 0 and 1.\n * @param minWidth Minimum width of the rectangle in percent, between 0 and 1.\n * @param maxWidth Maximum width of the rectangle in percent, between 0 and 1.\n */ const getRandomRectanglePolygonCss = ({ minHeight, maxHeight, minWidth, maxWidth })=>{\n    const height = Math.floor(Math.random() * ((maxHeight - minHeight) * 100 + 1)) + minHeight * 100;\n    const width = Math.floor(Math.random() * ((maxWidth - minWidth) * 100 + 1)) + minWidth * 100;\n    // Put this rectangle somewhere in the container so that it does not go out of the screen.\n    const top = Math.floor(Math.random() * (100 - height));\n    const left = Math.floor(Math.random() * (100 - width));\n    const topRight = `${left + width}% ${top}%`;\n    const bottomRight = `${left + width}% ${top + height}%`;\n    const bottomLeft = `${left}% ${top + height}%`;\n    const topLeft = `${left}% ${top}%`;\n    return `polygon(${topRight},${bottomRight},${bottomLeft},${topLeft})`;\n};\n/**\n * Generate a slice layer, slicing part of the element and moving it somwhere else.\n * @param options\n */ const generateGlitchSliceLayer = (options)=>{\n    const stepCount = Math.floor(options.slice.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for(let index = 0; index < stepCount; ++index){\n        if (getGlitchFactor(options, index / stepCount) === 0) {\n            steps.push({\n                opacity: \"0\",\n                transform: \"none\",\n                clipPath: \"unset\"\n            });\n            continue;\n        }\n        const translateX = getGlitchRandom(options, index / stepCount) * 30;\n        const styles = {\n            opacity: \"1\",\n            transform: `translate3d(${translateX}%,0,0)`,\n            clipPath: getRandomRectanglePolygonCss({\n                minHeight: options.slice.minHeight,\n                maxHeight: options.slice.maxHeight,\n                minWidth: 1,\n                maxWidth: 1\n            })\n        };\n        if (options.slice.hueRotate) styles.filter = `hue-rotate(${Math.floor(getGlitchRandom(options, index / stepCount) * 360)}deg)`;\n        steps.push(styles);\n    }\n    return {\n        steps,\n        timing: Object.assign({\n            easing: `steps(${stepCount},jump-start)`\n        }, options.timing)\n    };\n};\n/**\n * Generate a pulse layer, a single transparent and growing layer.\n * @param options\n */ const generateGlitchPulseLayer = (options)=>{\n    return !options.pulse ? null : {\n        steps: [\n            {\n                transform: \"scale(1)\",\n                opacity: \"1\"\n            },\n            {\n                transform: `scale(${options.pulse.scale})`,\n                opacity: \"0\"\n            }\n        ],\n        timing: Object.assign(Object.assign({}, options.timing), {\n            delay: (options.glitchTimeSpan ? options.glitchTimeSpan.start : 0) * options.timing.duration,\n            easing: \"ease-in-out\"\n        })\n    };\n};\n/**\n * Generate the base layer, which may or may not shake depending on the options.\n * @param options\n */ const generateBaseLayer = (options)=>{\n    if (!options.shake) return {\n        steps: [],\n        timing: {}\n    };\n    const stepCount = Math.floor(options.shake.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for(let index = 0; index < stepCount; ++index){\n        const translateX = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeX * 100;\n        const translateY = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeY * 100;\n        steps.push({\n            transform: `translate3d(${translateX}%,${translateY}%,0)`\n        });\n    }\n    return {\n        steps,\n        timing: Object.assign({\n            easing: `steps(${stepCount},jump-start)`\n        }, options.timing)\n    };\n};\n/**\n * Generate the layers that deterministically define a glitch animation for the specified options.\n */ const generateLayers = (options)=>[\n        generateBaseLayer(options),\n        generateGlitchPulseLayer(options),\n        ...Array.from({\n            length: options.slice.count\n        }).map(()=>generateGlitchSliceLayer(options))\n    ].filter((entry)=>entry !== null);\n/**\n* Performs a deep merge of option objects and returns new object. Does not modify\n* objects (immutable) and will ignore arrays.\n* @param objects - Objects to merge\n* @returns New object with merged key/values\n*/ // eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst mergeOptions = (...objects)=>{\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isObject = (obj)=>obj && typeof obj === \"object\";\n    return objects.reduce((prev, obj)=>{\n        Object.keys(obj).forEach((key)=>{\n            if (isObject(prev[key]) && isObject(obj[key])) prev[key] = (0, exports.mergeOptions)(prev[key], obj[key]);\n            else if (obj[key] !== undefined) prev[key] = obj[key];\n        });\n        return prev;\n    }, {});\n};\nexports.mergeOptions = mergeOptions;\n/**\n * Prepare the DOM to set up the glitch effect.\n * @remarks\n * Depending on the element state:\n *  - Whether it was glitched before or not,\n *  - Whether current element display attributes\n *  - Whether options.createContainers is true/false\n * The top-level container and layer containers might be different objects and might need to be created.\n * @param element\n * @param options\n * @returns\n */ const prepareGlitchElement = (element, options)=>{\n    var _a, _b;\n    // If not creating the containers\n    if (!options.createContainers) return {\n        container: element,\n        layersContainer: element,\n        glitched: element.firstElementChild\n    };\n    // If first glitch\n    if (!element.dataset.glitched) {\n        // Setup the layer container using grid to stack elements\n        const layersContainer = document.createElement(\"div\");\n        // If current element is an inline element\n        const container = document.createElement(\"div\");\n        if (getComputedStyle(element).getPropertyValue(\"display\").match(/^inline/)) container.style.display = \"inline-block\";\n        // Add the layers container to the global container\n        container.appendChild(layersContainer);\n        // Replace element with the new container\n        (_a = element.parentElement) === null || _a === void 0 || _a.insertBefore(container, element);\n        layersContainer.prepend(element);\n        return {\n            container,\n            layersContainer,\n            glitched: element\n        };\n    }\n    // Not first glitch, with createContainers=true\n    const layersContainer = element.parentElement;\n    const container = (_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.parentElement;\n    // Remove all glitch layers but keep the first one (which is the original element)\n    while(layersContainer.children.length > 1)layersContainer.removeChild(layersContainer.children[1]);\n    // Cancel the animation on the first layer\n    layersContainer.firstElementChild.getAnimations().forEach((animation)=>animation.cancel());\n    return {\n        container,\n        layersContainer,\n        glitched: element\n    };\n};\n/**\n * Given a set of computed layers and user options, glitch a given element\n * @param element\n * @param layers\n * @param options\n */ const glitchElement = (element, layers, options)=>{\n    const { glitched, container, layersContainer } = prepareGlitchElement(element, options);\n    // Force grid display on the layer container\n    layersContainer.style.display = \"grid\";\n    // Overflow\n    if (options.hideOverflow) container.style.overflow = \"hidden\";\n    // If setting HTML manually\n    if (options.html) glitched.innerHTML = options.html;\n    // Stack original element too (it is used as the base shaking layer)\n    glitched.style.gridArea = \"1/1/-1/-1\";\n    // Base layer\n    const baseLayer = glitched.cloneNode(true);\n    // Stack this layer\n    baseLayer.style.gridArea = \"1/1/-1/-1\";\n    baseLayer.style.userSelect = \"none\";\n    baseLayer.style.pointerEvents = \"none\";\n    baseLayer.style.opacity = \"0\";\n    for(let i = 0; i < layers.length - 1; ++i){\n        const layerDiv = baseLayer.cloneNode(true);\n        layersContainer.appendChild(layerDiv);\n    }\n    // Glitch control functions\n    const startGlitch = ()=>{\n        layers.forEach((layer, i)=>{\n            layersContainer.children[i].animate(layer.steps, layer.timing);\n        });\n    };\n    const stopGlitch = ()=>{\n        layers.forEach((_, i)=>{\n            layersContainer.children[i].getAnimations().forEach((animation)=>{\n                animation.cancel();\n            });\n        });\n    };\n    // Depending on the selected play mode, orchestrate when to start/stop the glitch\n    container.onmouseenter = null;\n    container.onmouseleave = null;\n    container.onclick = null;\n    switch(options.playMode){\n        case \"always\":\n            startGlitch();\n            break;\n        case \"hover\":\n            container.onmouseenter = startGlitch;\n            container.onmouseleave = stopGlitch;\n            break;\n        case \"click\":\n            container.onclick = ()=>{\n                stopGlitch();\n                startGlitch();\n            };\n            break;\n    }\n    // Mark the glitched element as glitched for next round\n    element.dataset.glitched = \"1\";\n    return {\n        container,\n        startGlitch,\n        stopGlitch\n    };\n};\n/**\n * Make a single element glitch.\n * @param elOrSelector What to glitch. Can be a query selector, a list of HTMLElement, an HTMLElement or a NodeList.\n * @param userOptions Optional glitch customization options.\n */ const glitch = (elOrSelector = \".powerglitch\", userOptions = {})=>{\n    // Fix options with defaults\n    const options = (0, exports.mergeOptions)(getDefaultOptions(userOptions.playMode), userOptions);\n    // Find elements to glitch\n    let elements = [];\n    if (typeof elOrSelector === \"string\") elements = Array.from(document.querySelectorAll(elOrSelector));\n    else if (elOrSelector instanceof NodeList) elements = Array.from(elOrSelector);\n    else if (Array.isArray(elOrSelector)) elements = elOrSelector;\n    else if (elOrSelector instanceof HTMLElement) elements = [\n        elOrSelector\n    ];\n    // Generate all animation layers\n    const layers = generateLayers(options);\n    // Animate each div element\n    const entries = elements.map((element)=>glitchElement(element, layers, options));\n    // Return list of containers and glitch control functions\n    return {\n        containers: entries.map((entry)=>entry.container),\n        startGlitch: ()=>entries.forEach((entry)=>entry.startGlitch()),\n        stopGlitch: ()=>entries.forEach((entry)=>entry.stopGlitch())\n    };\n};\nexports.PowerGlitch = {\n    glitch,\n    generateLayers,\n    getDefaultOptions\n};\n\n},{}],\"g7f4C\":[function(require,module,exports) {\nexports.interopDefault = function(a) {\n    return a && a.__esModule ? a : {\n        default: a\n    };\n};\nexports.defineInteropFlag = function(a) {\n    Object.defineProperty(a, \"__esModule\", {\n        value: true\n    });\n};\nexports.exportAll = function(source, dest) {\n    Object.keys(source).forEach(function(key) {\n        if (key === \"default\" || key === \"__esModule\" || Object.prototype.hasOwnProperty.call(dest, key)) return;\n        Object.defineProperty(dest, key, {\n            enumerable: true,\n            get: function() {\n                return source[key];\n            }\n        });\n    });\n    return dest;\n};\nexports.export = function(dest, destName, get) {\n    Object.defineProperty(dest, destName, {\n        enumerable: true,\n        get: get\n    });\n};\n\n},{}],\"j73bc\":[function(require,module,exports) {\nmodule.exports = require(\"ee6e19c2f39c411f\")(require(\"bbd6a80631fa700\").resolve(\"ivnvI\")).then(()=>module.bundle.root(\"fPvCC\"));\n\n},{\"ee6e19c2f39c411f\":\"7Yyte\",\"bbd6a80631fa700\":\"lK2dr\"}],\"7Yyte\":[function(require,module,exports) {\n\"use strict\";\nvar cacheLoader = require(\"78c38b45ffe75d74\");\nmodule.exports = cacheLoader(function(bundle) {\n    return new Promise(function(resolve, reject) {\n        // Don't insert the same script twice (e.g. if it was already in the HTML)\n        var existingScripts = document.getElementsByTagName(\"script\");\n        if ([].concat(existingScripts).some(function isCurrentBundle(script) {\n            return script.src === bundle;\n        })) {\n            resolve();\n            return;\n        }\n        var preloadLink = document.createElement(\"link\");\n        preloadLink.href = bundle;\n        preloadLink.rel = \"preload\";\n        preloadLink.as = \"script\";\n        document.head.appendChild(preloadLink);\n        var script = document.createElement(\"script\");\n        script.async = true;\n        script.type = \"text/javascript\";\n        script.src = bundle;\n        script.onerror = function(e) {\n            var error = new TypeError(\"Failed to fetch dynamically imported module: \".concat(bundle, \". Error: \").concat(e.message));\n            script.onerror = script.onload = null;\n            script.remove();\n            reject(error);\n        };\n        script.onload = function() {\n            script.onerror = script.onload = null;\n            resolve();\n        };\n        document.getElementsByTagName(\"head\")[0].appendChild(script);\n    });\n});\n\n},{\"78c38b45ffe75d74\":\"5XE0P\"}],\"5XE0P\":[function(require,module,exports) {\n\"use strict\";\nvar cachedBundles = {};\nvar cachedPreloads = {};\nvar cachedPrefetches = {};\nfunction getCache(type) {\n    switch(type){\n        case \"preload\":\n            return cachedPreloads;\n        case \"prefetch\":\n            return cachedPrefetches;\n        default:\n            return cachedBundles;\n    }\n}\nmodule.exports = function(loader, type) {\n    return function(bundle) {\n        var cache = getCache(type);\n        if (cache[bundle]) return cache[bundle];\n        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {\n            delete cache[bundle];\n            throw e;\n        });\n    };\n};\n\n},{}],\"03xZu\":[function(require,module,exports) {\nmodule.exports = Promise.all([\n    require(\"eb71671222e7a368\")(require(\"fab9887f175ffaaf\").resolve(\"7IF6M\")),\n    require(\"30e1b3a38f89bc52\")(require(\"fab9887f175ffaaf\").resolve(\"iGomz\"))\n]).then(()=>module.bundle.root(\"asAuK\"));\n\n},{\"eb71671222e7a368\":\"lqqRw\",\"fab9887f175ffaaf\":\"lK2dr\",\"30e1b3a38f89bc52\":\"7Yyte\"}],\"lqqRw\":[function(require,module,exports) {\n\"use strict\";\nvar cacheLoader = require(\"ed80c65697f1d829\");\nmodule.exports = cacheLoader(function(bundle) {\n    return new Promise(function(resolve, reject) {\n        // Don't insert the same link element twice (e.g. if it was already in the HTML)\n        var existingLinks = document.getElementsByTagName(\"link\");\n        if ([].concat(existingLinks).some(function isCurrentBundle(link) {\n            return link.href === bundle && link.rel.indexOf(\"stylesheet\") > -1;\n        })) {\n            resolve();\n            return;\n        }\n        var link = document.createElement(\"link\");\n        link.rel = \"stylesheet\";\n        link.href = bundle;\n        link.onerror = function(e) {\n            link.onerror = link.onload = null;\n            link.remove();\n            reject(e);\n        };\n        link.onload = function() {\n            link.onerror = link.onload = null;\n            resolve();\n        };\n        document.getElementsByTagName(\"head\")[0].appendChild(link);\n    });\n});\n\n},{\"ed80c65697f1d829\":\"5XE0P\"}],\"6wzql\":[function(require,module,exports) {\nmodule.exports = require(\"ee14cb365d1d8b2d\").getBundleURL(\"9ltx4\") + \"serviceWorker.js\";\n\n},{\"ee14cb365d1d8b2d\":\"6fsuZ\"}]},[\"lwVbV\",\"8RSWf\"], \"8RSWf\", \"parcelRequire6566\")\n\n//# sourceMappingURL=index.afac7dd3.js.map\n","require('./helpers/bundle-manifest').register(require('./helpers/bundle-url').getBundleURL('9ltx4'),JSON.parse(\"[\\\"9ltx4\\\",\\\"index.afac7dd3.js\\\",\\\"ivnvI\\\",\\\"ResizeObserver.es.b8944159.js\\\",\\\"iGomz\\\",\\\"contactDialog.cd9f0fae.js\\\",\\\"6kmWC\\\",\\\"tpl.7f3037e4.html\\\",\\\"7IF6M\\\",\\\"contactDialog.ca8e93b2.css\\\",\\\"g8wR7\\\",\\\"serviceWorker.js\\\",\\\"8l6DZ\\\",\\\"index.19735fb6.css\\\"]\"));","\"use strict\";\n\nvar mapping = new Map();\nfunction register(baseUrl, manifest) {\n  for (var i = 0; i < manifest.length - 1; i += 2) {\n    mapping.set(manifest[i], {\n      baseUrl: baseUrl,\n      path: manifest[i + 1]\n    });\n  }\n}\nfunction resolve(id) {\n  var resolved = mapping.get(id);\n  if (resolved == null) {\n    throw new Error('Could not resolve bundle with id ' + id);\n  }\n  return new URL(resolved.path, resolved.baseUrl).toString();\n}\nmodule.exports.register = register;\nmodule.exports.resolve = resolve;","\"use strict\";\n\nvar bundleURL = {};\nfunction getBundleURLCached(id) {\n  var value = bundleURL[id];\n  if (!value) {\n    value = getBundleURL();\n    bundleURL[id] = value;\n  }\n  return value;\n}\nfunction getBundleURL() {\n  try {\n    throw new Error();\n  } catch (err) {\n    var matches = ('' + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^)\\n]+/g);\n    if (matches) {\n      // The first two stack frames will be this function and getBundleURLCached.\n      // Use the 3rd one, which will be a runtime in the original bundle.\n      return getBaseURL(matches[2]);\n    }\n  }\n  return '/';\n}\nfunction getBaseURL(url) {\n  return ('' + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/.+)\\/[^/]+$/, '$1') + '/';\n}\n\n// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.\nfunction getOrigin(url) {\n  var matches = ('' + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\\/\\/[^/]+/);\n  if (!matches) {\n    throw new Error('Origin not found');\n  }\n  return matches[0];\n}\nexports.getBundleURL = getBundleURLCached;\nexports.getBaseURL = getBaseURL;\nexports.getOrigin = getOrigin;","/// <reference lib=\"dom\" />\n\nimport \"regenerator-runtime/runtime\";\nimport type ResizeObserverType from \"resize-observer-polyfill\";\nimport \"./index.scss\";\nimport type { ContactDialogCtrl } from \"./contactDialog\";\nimport domready from \"domready\";\nimport { startLogoAnimation } from \"./logo.ctrl\";\n\ndeclare global {\n    interface Window {\n        ResizeObserver: typeof ResizeObserverType;\n    }\n}\n\n(async () => {\n    if (!window.ResizeObserver) {\n        const { default: ResizeObserver } = await import(\n            \"resize-observer-polyfill\"\n        );\n        window.ResizeObserver = ResizeObserver;\n    }\n\n    if (!matchMedia(\"(prefers-reduced-motion: reduce)\").matches) {\n        const loadEls = document.body.querySelectorAll(\".load-fadeinup\");\n\n        domready(() =>\n            setTimeout(\n                () =>\n                    loadEls.forEach((el, i) =>\n                        setTimeout(() => el.classList.add(\"in\"), 300 * i),\n                    ),\n                3500,\n            ),\n        );\n\n        const logo = document.querySelector<SVGSVGElement>(\".icon-logomark\")!;\n\n        startLogoAnimation(logo);\n    }\n\n    let contactDialogCtrl: ContactDialogCtrl;\n\n    document.body\n        .querySelector<HTMLButtonElement>(\".btn--contact\")!\n        .addEventListener(\"click\", async function () {\n            if (!contactDialogCtrl) {\n                this.disabled = true;\n                const contactDialogModule = await import(\n                    \"./contactDialog\"\n                ).catch(() => (this.disabled = false as false));\n                if (!contactDialogModule) return;\n                contactDialogCtrl = new contactDialogModule.ContactDialogCtrl();\n                await contactDialogModule.ContactDialogCtrl.templateLoader;\n\n                document.body\n                    .querySelector(\".content\")!\n                    .insertAdjacentElement(\n                        \"afterbegin\",\n                        contactDialogCtrl.element,\n                    );\n                this.disabled = false;\n            }\n\n            contactDialogCtrl.isShown()\n                ? contactDialogCtrl.hide()\n                : contactDialogCtrl.show();\n        });\n\n    const themes: string[] = [];\n    document.body.querySelectorAll(\".btn[data-theme]\").forEach((btn) => {\n        const theme = btn.getAttribute(\"data-theme\")!;\n        themes.push(theme);\n        btn.addEventListener(\"click\", () => {\n            localStorage.setItem(\"FRS:theme\", theme);\n            themes.forEach((theme) =>\n                document.body.classList.remove(\"t-\" + theme),\n            );\n            document.body.classList.add(\"t-\" + theme);\n        });\n    });\n\n    if (\"serviceWorker\" in navigator) {\n        navigator.serviceWorker\n            .register(new URL(\"./serviceWorker.ts\", import.meta.url), {\n                type: \"module\",\n            })\n            .catch((err) =>\n                console.log(\"Service worker registration failed: \" + err),\n            );\n    }\n})();\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) });\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: true });\n  defineProperty(\n    GeneratorFunctionPrototype,\n    \"constructor\",\n    { value: GeneratorFunction, configurable: true }\n  );\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    defineProperty(this, \"_invoke\", { value: enqueue });\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per GeneratorResume behavior specified since ES2015:\n        // ES2015 spec, step 3: https://262.ecma-international.org/6.0/#sec-generatorresume\n        // Latest spec, step 2: https://tc39.es/ecma262/#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method;\n    var method = delegate.iterator[methodName];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method, or a missing .next method, always terminate the\n      // yield* loop.\n      context.delegate = null;\n\n      // Note: [\"return\"] must be used for ES3 parsing compatibility.\n      if (methodName === \"throw\" && delegate.iterator[\"return\"]) {\n        // If the delegate iterator has a return method, give it a\n        // chance to clean up.\n        context.method = \"return\";\n        context.arg = undefined;\n        maybeInvokeDelegate(delegate, context);\n\n        if (context.method === \"throw\") {\n          // If maybeInvokeDelegate(context) changed context.method from\n          // \"return\" to \"throw\", let that override the TypeError below.\n          return ContinueSentinel;\n        }\n      }\n      if (methodName !== \"return\") {\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a '\" + methodName + \"' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(val) {\n    var object = Object(val);\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable != null) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    throw new TypeError(typeof iterable + \" is not iterable\");\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","/*!\n  * domready (c) Dustin Diaz 2014 - License MIT\n  */\n!function (name, definition) {\n\n  if (typeof module != 'undefined') module.exports = definition()\n  else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)\n  else this[name] = definition()\n\n}('domready', function () {\n\n  var fns = [], listener\n    , doc = document\n    , hack = doc.documentElement.doScroll\n    , domContentLoaded = 'DOMContentLoaded'\n    , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)\n\n\n  if (!loaded)\n  doc.addEventListener(domContentLoaded, listener = function () {\n    doc.removeEventListener(domContentLoaded, listener)\n    loaded = 1\n    while (listener = fns.shift()) listener()\n  })\n\n  return function (fn) {\n    loaded ? setTimeout(fn, 0) : fns.push(fn)\n  }\n\n});\n","import { PowerGlitch } from \"powerglitch\";\n\nconst randInt = (a: number = 0, b: number = 1) => Math.random() * (b - a) + a;\n\nconst getItemsToReveal = (logo: SVGElement) => {\n    const paths = Array.from(\n        logo.querySelectorAll<HTMLElement | SVGElement>(\"path\"),\n    );\n\n    paths.push(logo!.querySelector<SVGSVGElement>(\"use\")!);\n\n    return paths;\n};\n\nexport const startLogoAnimation = (logo: SVGElement) => {\n    let lastVisibleItem = -1;\n\n    let itemsToReveal = [getItemsToReveal(logo)];\n\n    itemsToReveal[0].forEach((item) => (item.style.visibility = \"hidden\"));\n\n    const glitchWrapper = document.createElement(\"div\");\n    glitchWrapper.style.width = \"100%\";\n    glitchWrapper.style.height = \"100%\";\n    logo.parentElement!.appendChild(glitchWrapper);\n    glitchWrapper.appendChild(logo);\n\n    const progressReveal = async () => {\n        let timeout: number;\n        if (lastVisibleItem === itemsToReveal[0].length - 1) {\n            timeout = randInt(1000, 6000);\n        } else {\n            ++lastVisibleItem;\n            itemsToReveal.forEach(\n                (glitchElement) =>\n                    (glitchElement[lastVisibleItem].style.visibility =\n                        \"visible\"),\n            );\n            timeout = randInt(300, 700);\n        }\n\n        reinitGlitch();\n\n        setTimeout(progressReveal.bind(this), timeout);\n    };\n\n    const reinitGlitch = () => {\n        PowerGlitch.glitch(glitchWrapper, {\n            timing: {\n                duration: randInt(300, 2000),\n                iterations: 1,\n            },\n        });\n    };\n\n    const initGlitch = () => {\n        reinitGlitch();\n\n        itemsToReveal = Array.from(\n            glitchWrapper.parentElement!.querySelectorAll<SVGElement>(\n                \"svg[role=img]\",\n            ),\n        ).map((glitchElement) => getItemsToReveal(glitchElement));\n\n        glitchWrapper.parentElement!.style.width =\n            glitchWrapper.parentElement!.parentElement!.style.width = \"100%\";\n        glitchWrapper.parentElement!.style.height =\n            glitchWrapper.parentElement!.parentElement!.style.height = \"100%\";\n        glitchWrapper.parentElement!.style.gridTemplate = \"50% 50% / 50% 50%\";\n    };\n\n    setTimeout(progressReveal.bind(this), 2500); // starting timeout\n    initGlitch();\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PowerGlitch = exports.mergeOptions = void 0;\n/**\n * Get best-looking default options for most elements for a given playMode.\n */\nconst getDefaultOptions = (playMode = 'always') => {\n    return {\n        playMode,\n        createContainers: true,\n        hideOverflow: false,\n        timing: playMode === 'always' ? { duration: 2 * 1000, iterations: Infinity } : { duration: 250, iterations: 1 },\n        glitchTimeSpan: playMode === 'always' ? { start: 0.5, end: 0.7 } : { start: 0, end: 1, },\n        shake: {\n            velocity: 15,\n            amplitudeX: 0.2,\n            amplitudeY: 0.2,\n        },\n        slice: playMode === 'click' ? {\n            count: 15,\n            velocity: 20,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true,\n        } : {\n            count: 6,\n            velocity: 15,\n            minHeight: 0.02,\n            maxHeight: 0.15,\n            hueRotate: true,\n        },\n        pulse: false,\n    };\n};\n/**\n * Glitch factor function, returns a value between 0 and 1 telling how much the animation should glitch at a given stepPct.\n */\nconst getGlitchFactor = (options, stepPct) => {\n    if (!options.glitchTimeSpan) {\n        return 1;\n    }\n    const glitchStart = options.glitchTimeSpan.start;\n    const glitchEnd = options.glitchTimeSpan.end;\n    if (stepPct < glitchStart || stepPct > glitchEnd) {\n        return 0;\n    }\n    const glitchPeak = glitchStart + (glitchEnd - glitchStart) / 2;\n    if (stepPct < glitchPeak) {\n        return (stepPct - glitchStart) / (glitchPeak - glitchStart);\n    }\n    else {\n        return (glitchEnd - stepPct) / (glitchEnd - glitchPeak);\n    }\n};\n/**\n * Get a random value between -1 and 1, which biases towards the center if the animation should not glitch at the given `stepPct` moment.\n */\nconst getGlitchRandom = (options, stepPct) => {\n    return (Math.random() - .5) * 2 * getGlitchFactor(options, stepPct);\n};\n/**\n * Get a random rectangle values in % to glitch. Percent values are between 0 and 100. Returns the rectangle as a CSS polygon.\n * @param minHeight Minimum height of the rectangle in percent, between 0 and 1.\n * @param maxHeight Maximum height of the rectangle in percent, between 0 and 1.\n * @param minWidth Minimum width of the rectangle in percent, between 0 and 1.\n * @param maxWidth Maximum width of the rectangle in percent, between 0 and 1.\n */\nconst getRandomRectanglePolygonCss = ({ minHeight, maxHeight, minWidth, maxWidth }) => {\n    const height = Math.floor(Math.random() * ((maxHeight - minHeight) * 100 + 1)) + minHeight * 100;\n    const width = Math.floor(Math.random() * ((maxWidth - minWidth) * 100 + 1)) + minWidth * 100;\n    // Put this rectangle somewhere in the container so that it does not go out of the screen.\n    const top = Math.floor(Math.random() * (100 - height));\n    const left = Math.floor(Math.random() * (100 - width));\n    const topRight = `${left + width}% ${top}%`;\n    const bottomRight = `${left + width}% ${top + height}%`;\n    const bottomLeft = `${left}% ${top + height}%`;\n    const topLeft = `${left}% ${top}%`;\n    return `polygon(${topRight},${bottomRight},${bottomLeft},${topLeft})`;\n};\n/**\n * Generate a slice layer, slicing part of the element and moving it somwhere else.\n * @param options\n */\nconst generateGlitchSliceLayer = (options) => {\n    const stepCount = Math.floor(options.slice.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        if (getGlitchFactor(options, index / stepCount) === 0) {\n            steps.push({\n                opacity: '0',\n                transform: 'none',\n                clipPath: 'unset',\n            });\n            continue;\n        }\n        const translateX = getGlitchRandom(options, index / stepCount) * 30;\n        const styles = {\n            opacity: '1',\n            transform: `translate3d(${translateX}%,0,0)`,\n            clipPath: getRandomRectanglePolygonCss({ minHeight: options.slice.minHeight, maxHeight: options.slice.maxHeight, minWidth: 1, maxWidth: 1 }),\n        };\n        if (options.slice.hueRotate) {\n            styles.filter = `hue-rotate(${Math.floor(getGlitchRandom(options, index / stepCount) * 360)}deg)`;\n        }\n        steps.push(styles);\n    }\n    return {\n        steps,\n        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing),\n    };\n};\n/**\n * Generate a pulse layer, a single transparent and growing layer.\n * @param options\n */\nconst generateGlitchPulseLayer = (options) => {\n    return !options.pulse ? null : {\n        steps: [\n            { transform: 'scale(1)', opacity: '1', },\n            { transform: `scale(${options.pulse.scale})`, opacity: '0', },\n        ],\n        timing: Object.assign(Object.assign({}, options.timing), { delay: (options.glitchTimeSpan ? options.glitchTimeSpan.start : 0) * options.timing.duration, easing: 'ease-in-out' }),\n    };\n};\n/**\n * Generate the base layer, which may or may not shake depending on the options.\n * @param options\n */\nconst generateBaseLayer = (options) => {\n    if (!options.shake) {\n        return { steps: [], timing: {} };\n    }\n    const stepCount = Math.floor(options.shake.velocity * options.timing.duration / 1000) + 1;\n    const steps = [];\n    for (let index = 0; index < stepCount; ++index) {\n        const translateX = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeX * 100;\n        const translateY = getGlitchRandom(options, index / stepCount) * options.shake.amplitudeY * 100;\n        steps.push({\n            transform: `translate3d(${translateX}%,${translateY}%,0)`,\n        });\n    }\n    return {\n        steps,\n        timing: Object.assign({ easing: `steps(${stepCount},jump-start)` }, options.timing),\n    };\n};\n/**\n * Generate the layers that deterministically define a glitch animation for the specified options.\n */\nconst generateLayers = (options) => [\n    generateBaseLayer(options),\n    generateGlitchPulseLayer(options),\n    ...Array.from({ length: options.slice.count }).map(() => generateGlitchSliceLayer(options)),\n].filter(entry => entry !== null);\n/**\n* Performs a deep merge of option objects and returns new object. Does not modify\n* objects (immutable) and will ignore arrays.\n* @param objects - Objects to merge\n* @returns New object with merged key/values\n*/\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst mergeOptions = (...objects) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const isObject = (obj) => obj && typeof obj === 'object';\n    return objects.reduce((prev, obj) => {\n        Object.keys(obj)\n            .forEach(key => {\n            if (isObject(prev[key]) && isObject(obj[key])) {\n                prev[key] = (0, exports.mergeOptions)(prev[key], obj[key]);\n            }\n            else if (obj[key] !== undefined) {\n                prev[key] = obj[key];\n            }\n        });\n        return prev;\n    }, {});\n};\nexports.mergeOptions = mergeOptions;\n/**\n * Prepare the DOM to set up the glitch effect.\n * @remarks\n * Depending on the element state:\n *  - Whether it was glitched before or not,\n *  - Whether current element display attributes\n *  - Whether options.createContainers is true/false\n * The top-level container and layer containers might be different objects and might need to be created.\n * @param element\n * @param options\n * @returns\n */\nconst prepareGlitchElement = (element, options) => {\n    var _a, _b;\n    // If not creating the containers\n    if (!options.createContainers) {\n        return {\n            container: element,\n            layersContainer: element,\n            glitched: element.firstElementChild,\n        };\n    }\n    // If first glitch\n    if (!element.dataset.glitched) {\n        // Setup the layer container using grid to stack elements\n        const layersContainer = document.createElement('div');\n        // If current element is an inline element\n        const container = document.createElement('div');\n        if (getComputedStyle(element).getPropertyValue('display').match(/^inline/)) {\n            container.style.display = 'inline-block';\n        }\n        // Add the layers container to the global container\n        container.appendChild(layersContainer);\n        // Replace element with the new container\n        (_a = element.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(container, element);\n        layersContainer.prepend(element);\n        return {\n            container,\n            layersContainer,\n            glitched: element,\n        };\n    }\n    // Not first glitch, with createContainers=true\n    const layersContainer = element.parentElement;\n    const container = (_b = element.parentElement) === null || _b === void 0 ? void 0 : _b.parentElement;\n    // Remove all glitch layers but keep the first one (which is the original element)\n    while (layersContainer.children.length > 1) {\n        layersContainer.removeChild(layersContainer.children[1]);\n    }\n    // Cancel the animation on the first layer\n    layersContainer.firstElementChild.getAnimations().forEach(animation => animation.cancel());\n    return {\n        container,\n        layersContainer,\n        glitched: element,\n    };\n};\n/**\n * Given a set of computed layers and user options, glitch a given element\n * @param element\n * @param layers\n * @param options\n */\nconst glitchElement = (element, layers, options) => {\n    const { glitched, container, layersContainer } = prepareGlitchElement(element, options);\n    // Force grid display on the layer container\n    layersContainer.style.display = 'grid';\n    // Overflow\n    if (options.hideOverflow) {\n        container.style.overflow = 'hidden';\n    }\n    // If setting HTML manually\n    if (options.html) {\n        glitched.innerHTML = options.html;\n    }\n    // Stack original element too (it is used as the base shaking layer)\n    glitched.style.gridArea = '1/1/-1/-1';\n    // Base layer\n    const baseLayer = glitched.cloneNode(true);\n    // Stack this layer\n    baseLayer.style.gridArea = '1/1/-1/-1';\n    baseLayer.style.userSelect = 'none';\n    baseLayer.style.pointerEvents = 'none';\n    baseLayer.style.opacity = '0';\n    for (let i = 0; i < layers.length - 1; ++i) {\n        const layerDiv = baseLayer.cloneNode(true);\n        layersContainer.appendChild(layerDiv);\n    }\n    // Glitch control functions\n    const startGlitch = () => {\n        layers.forEach((layer, i) => {\n            layersContainer\n                .children[i]\n                .animate(layer.steps, layer.timing);\n        });\n    };\n    const stopGlitch = () => {\n        layers.forEach((_, i) => {\n            layersContainer\n                .children[i]\n                .getAnimations()\n                .forEach(animation => {\n                animation.cancel();\n            });\n        });\n    };\n    // Depending on the selected play mode, orchestrate when to start/stop the glitch\n    container.onmouseenter = null;\n    container.onmouseleave = null;\n    container.onclick = null;\n    switch (options.playMode) {\n        case 'always':\n            startGlitch();\n            break;\n        case 'hover':\n            container.onmouseenter = startGlitch;\n            container.onmouseleave = stopGlitch;\n            break;\n        case 'click':\n            container.onclick = () => { stopGlitch(); startGlitch(); };\n            break;\n    }\n    // Mark the glitched element as glitched for next round\n    element.dataset.glitched = '1';\n    return { container, startGlitch, stopGlitch };\n};\n/**\n * Make a single element glitch.\n * @param elOrSelector What to glitch. Can be a query selector, a list of HTMLElement, an HTMLElement or a NodeList.\n * @param userOptions Optional glitch customization options.\n */\nconst glitch = (elOrSelector = '.powerglitch', userOptions = {}) => {\n    // Fix options with defaults\n    const options = (0, exports.mergeOptions)(getDefaultOptions(userOptions.playMode), userOptions);\n    // Find elements to glitch\n    let elements = [];\n    if (typeof elOrSelector === 'string') {\n        elements = Array.from(document.querySelectorAll(elOrSelector));\n    }\n    else if (elOrSelector instanceof NodeList) {\n        elements = Array.from(elOrSelector);\n    }\n    else if (Array.isArray(elOrSelector)) {\n        elements = elOrSelector;\n    }\n    else if (elOrSelector instanceof HTMLElement) {\n        elements = [elOrSelector];\n    }\n    // Generate all animation layers\n    const layers = generateLayers(options);\n    // Animate each div element\n    const entries = elements.map(element => glitchElement(element, layers, options));\n    // Return list of containers and glitch control functions\n    return {\n        containers: entries.map(entry => entry.container),\n        startGlitch: () => entries.forEach(entry => entry.startGlitch()),\n        stopGlitch: () => entries.forEach(entry => entry.stopGlitch()),\n    };\n};\nexports.PowerGlitch = {\n    glitch,\n    generateLayers,\n    getDefaultOptions,\n};\n","exports.interopDefault = function (a) {\n  return a && a.__esModule ? a : {default: a};\n};\n\nexports.defineInteropFlag = function (a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n};\n\nexports.exportAll = function (source, dest) {\n  Object.keys(source).forEach(function (key) {\n    if (\n      key === 'default' ||\n      key === '__esModule' ||\n      Object.prototype.hasOwnProperty.call(dest, key)\n    ) {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function () {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n};\n\nexports.export = function (dest, destName, get) {\n  Object.defineProperty(dest, destName, {\n    enumerable: true,\n    get: get,\n  });\n};\n","module.exports = (require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"ivnvI\"))).then(() => module.bundle.root('fPvCC'));","\"use strict\";\n\nvar cacheLoader = require('../cacheLoader');\nmodule.exports = cacheLoader(function (bundle) {\n  return new Promise(function (resolve, reject) {\n    // Don't insert the same script twice (e.g. if it was already in the HTML)\n    var existingScripts = document.getElementsByTagName('script');\n    if ([].concat(existingScripts).some(function isCurrentBundle(script) {\n      return script.src === bundle;\n    })) {\n      resolve();\n      return;\n    }\n    var preloadLink = document.createElement('link');\n    preloadLink.href = bundle;\n    preloadLink.rel = 'preload';\n    preloadLink.as = 'script';\n    document.head.appendChild(preloadLink);\n    var script = document.createElement('script');\n    script.async = true;\n    script.type = 'text/javascript';\n    script.src = bundle;\n    script.onerror = function (e) {\n      var error = new TypeError(\"Failed to fetch dynamically imported module: \".concat(bundle, \". Error: \").concat(e.message));\n      script.onerror = script.onload = null;\n      script.remove();\n      reject(error);\n    };\n    script.onload = function () {\n      script.onerror = script.onload = null;\n      resolve();\n    };\n    document.getElementsByTagName('head')[0].appendChild(script);\n  });\n});","\"use strict\";\n\nvar cachedBundles = {};\nvar cachedPreloads = {};\nvar cachedPrefetches = {};\nfunction getCache(type) {\n  switch (type) {\n    case 'preload':\n      return cachedPreloads;\n    case 'prefetch':\n      return cachedPrefetches;\n    default:\n      return cachedBundles;\n  }\n}\nmodule.exports = function (loader, type) {\n  return function (bundle) {\n    var cache = getCache(type);\n    if (cache[bundle]) {\n      return cache[bundle];\n    }\n    return cache[bundle] = loader.apply(null, arguments).catch(function (e) {\n      delete cache[bundle];\n      throw e;\n    });\n  };\n};","module.exports = Promise.all([require(\"./helpers/browser/css-loader\")(require('./helpers/bundle-manifest').resolve(\"7IF6M\")), require(\"./helpers/browser/js-loader\")(require('./helpers/bundle-manifest').resolve(\"iGomz\"))]).then(() => module.bundle.root('asAuK'));","\"use strict\";\n\nvar cacheLoader = require('../cacheLoader');\nmodule.exports = cacheLoader(function (bundle) {\n  return new Promise(function (resolve, reject) {\n    // Don't insert the same link element twice (e.g. if it was already in the HTML)\n    var existingLinks = document.getElementsByTagName('link');\n    if ([].concat(existingLinks).some(function isCurrentBundle(link) {\n      return link.href === bundle && link.rel.indexOf('stylesheet') > -1;\n    })) {\n      resolve();\n      return;\n    }\n    var link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.href = bundle;\n    link.onerror = function (e) {\n      link.onerror = link.onload = null;\n      link.remove();\n      reject(e);\n    };\n    link.onload = function () {\n      link.onerror = link.onload = null;\n      resolve();\n    };\n    document.getElementsByTagName('head')[0].appendChild(link);\n  });\n});","module.exports = require('./helpers/bundle-url').getBundleURL('9ltx4') + \"serviceWorker.js\";"],"names":["modules","entry","mainEntry","parcelRequireName","globalName","globalObject","globalThis","self","window","global","previousRequire","cache","nodeRequire","module","require","bind","newRequire","name","jumped","currentRequire","err","Error","code","localRequire","resolve","x","id","Module","call","exports","res","isParcelRequire","moduleName","bundle","parent","register","Object","defineProperty","get","i","length","mainExports","define","amd","getBundleURL","JSON","parse","mapping","Map","baseUrl","manifest","set","path","resolved","URL","toString","bundleURL","getBaseURL","url","replace","value","matches","stack","match","getOrigin","parcelHelpers","_domready","_domreadyDefault","interopDefault","_logoCtrl","contactDialogCtrl","ResizeObserver","default","matchMedia","loadEls","document","body","querySelectorAll","setTimeout","forEach","el","classList","add","logo","querySelector","startLogoAnimation","addEventListener","disabled","contactDialogModule","catch","ContactDialogCtrl","templateLoader","insertAdjacentElement","element","isShown","hide","show","themes","btn","theme","getAttribute","push","localStorage","setItem","remove","navigator","serviceWorker","console","log","runtime","undefined","Op","prototype","hasOwn","hasOwnProperty","obj","key","desc","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","enumerable","configurable","writable","wrap","innerFn","outerFn","tryLocsList","context","state","generator","create","protoGenerator","Generator","Context","GenStateSuspendedStart","method","arg","GenStateExecuting","GenStateCompleted","done","delegate","delegateResult","maybeInvokeDelegate","methodName","TypeError","ContinueSentinel","record","tryCatch","type","info","resultName","next","nextLoc","sent","_sent","dispatchException","abrupt","fn","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","_invoke","AsyncIterator","PromiseImpl","previousPromise","callInvokeWithMethodAndArg","reject","invoke","result","__await","then","unwrapped","error","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","displayName","isGeneratorFunction","genFun","ctor","constructor","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","slice","stop","rootRecord","rootEntry","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","definition","listener","fns","doc","hack","documentElement","doScroll","domContentLoaded","loaded","test","readyState","removeEventListener","shift","defineInteropFlag","export","_powerglitch","randInt","a","b","Math","random","getItemsToReveal","paths","Array","from","lastVisibleItem","itemsToReveal","item","style","visibility","glitchWrapper","createElement","width","height","parentElement","appendChild","progressReveal","timeout","glitchElement","reinitGlitch","PowerGlitch","glitch","timing","duration","iterations","map","gridTemplate","mergeOptions","getDefaultOptions","playMode","createContainers","hideOverflow","Infinity","glitchTimeSpan","start","end","shake","velocity","amplitudeX","amplitudeY","count","minHeight","maxHeight","hueRotate","pulse","getGlitchFactor","options","stepPct","glitchStart","glitchEnd","glitchPeak","getGlitchRandom","getRandomRectanglePolygonCss","minWidth","maxWidth","floor","top","left","topRight","bottomRight","bottomLeft","topLeft","generateGlitchSliceLayer","stepCount","steps","index","opacity","transform","clipPath","translateX","styles","filter","assign","easing","generateGlitchPulseLayer","scale","delay","generateBaseLayer","translateY","generateLayers","objects","isObject","reduce","prepareGlitchElement","_a","_b","container","layersContainer","glitched","firstElementChild","dataset","getComputedStyle","getPropertyValue","display","insertBefore","prepend","children","removeChild","getAnimations","animation","cancel","layers","overflow","html","innerHTML","gridArea","baseLayer","cloneNode","userSelect","pointerEvents","layerDiv","startGlitch","layer","animate","stopGlitch","_","onmouseenter","onmouseleave","onclick","elOrSelector","userOptions","elements","NodeList","isArray","HTMLElement","entries","containers","__esModule","exportAll","source","dest","destName","root","cacheLoader","concat","getElementsByTagName","some","script","src","preloadLink","href","rel","as","head","onerror","e","message","onload","cachedBundles","cachedPreloads","cachedPrefetches","loader","getCache","apply","arguments","all","link","indexOf"],"version":3,"file":"index.afac7dd3.js.map"}