{"mappings":"2mCAAMA,EAAa,kBAAqBC,KAAaC,mBAAmBC,KAAIC,GAAKA,EAAEC,WAAUC,KAAK,IAC5FC,EAAeN,KAAaC,mBAAmBC,KAAIC,GAAKA,EAAEI,MAEhED,EAAYE,QACV,0FACA,oEACA,0HACA,oBACA,qBACA,eACA,qBACA,cACA,eAIFR,KAAKS,iBAAiB,WAAWC,IAG9BA,EAAcC,UAEbC,OAAOC,KAAKd,GAAYe,MAAKC,GAASA,EAAMC,OAAOV,SAOvDN,KAAKS,iBAAiB,YAAYC,IAC7BA,EAAcC,UAEfC,OACGK,OAEAH,MAAKG,GACJC,QAAQC,IACNF,EAEGG,QAAOC,GAAOA,IAAQtB,IAEtBG,KAAImB,GAAOT,OAAOU,OAAOD,YAQtCrB,KAAKS,iBAAiB,SAAS,SAASC,GAGrCA,EAAca,YAEbX,OAAOY,MAAOd,EAAce,SAASX,MAAKY,GAEpCA,GAGFC,MAAOjB,EAAce,SAElBX,MAAKY,GACJd,OAAOC,KAAKd,GAETe,MAAKC,IAGJA,EAAMa,IAAKlB,EAAce,QAASC,EAASG,SACpCH,OAGZI,OAAM,IAAMC,QAAQC,IAAI","sources":["./src/serviceWorker.ts"],"sourcesContent":["const CACHE_NAME = 'frsource-cache-' + (self as any).__precacheManifest.map(p => p.revision).join('');\nconst urlsToCache = (self as any).__precacheManifest.map(p => p.url)\n;\nurlsToCache.unshift(\n  'https://www.frsource.org/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js',\n  'https://fonts.googleapis.com/css2?family=Inconsolata&display=swap',\n  'https://fonts.gstatic.com/s/inconsolata/v20/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WR32kXWdycuJDA.woff',\n  '/site.webmanifest',\n  '/browserconfig.xml',\n  '/favicon.ico',\n  '/favicon-32x32.png',\n  '/robots.txt',\n  '/humans.txt',\n);\n\n// Listen for the install event, which fires when the service worker is installing\nself.addEventListener('install', event => {\n  // Ensures the install event doesn't complete until after the cache promise resolves\n  // This is so we don't move on to other events until the critical initial cache is done\n  (event as any).waitUntil(\n    // Open a named cache, then add all the specified URLs to it\n    caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))\n  );\n});\n\n// Listen for the activate event, which is fired after installation\n// Activate is when the service worker actually takes over from the previous\n// version, which is a good time to clean up old caches\nself.addEventListener('activate', event => {\n    (event as any).waitUntil(\n    // Get the keys of all the old caches\n    caches\n      .keys()\n      // Ensure we don't resolve until all the promises do (i.e. each key has been deleted)\n      .then(keys =>\n        Promise.all(\n          keys\n            // Remove any cache that not matches the current cache name\n            .filter(key => key !== CACHE_NAME)\n            // Map over the array of old cache names and delete them all\n            .map(key => caches.delete(key))\n        )\n      )\n  );\n});\n\n// Listen for browser fetch events. These fire any time the browser tries to load\n// any outside resources\nself.addEventListener('fetch', function(event) {\n  // This lets us control the response\n  // We pass in a promise that resolves with a response object\n  (event as any).respondWith(\n    // Check whether we have a matching response for this request in our cache\n    caches.match((event as any).request).then(response => {\n      // It's in the cache! Serve the response straight from there\n      if (response) return response;\n      // If it's not in the cache we make a fetch request for the resource\n      return (\n        fetch((event as any).request)\n          // Then we open our cache\n          .then(response => \n            caches.open(CACHE_NAME)\n              // Then we put the request into the cache, so we have it offline next time\n              .then(cache => {\n                // We have to clone the response as response streams can only be read once\n                // This way we can put one copy in the cache and return the other to the browser\n                cache.put((event as any).request, response.clone());\n                return response;\n              })\n          )\n          .catch(() => console.log('Fetch failed, sorry.'))\n      );\n    })\n  );\n});"],"names":["CACHE_NAME","self","__precacheManifest","map","p","revision","join","urlsToCache","url","unshift","addEventListener","event","waitUntil","caches","open","then","cache","addAll","keys","Promise","all","filter","key","delete","respondWith","match","request","response","fetch","put","clone","catch","console","log"],"version":3,"file":"serviceWorker.e525df9f.js.map"}