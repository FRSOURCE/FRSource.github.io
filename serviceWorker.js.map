{"mappings":"gvCAAAA,KAAKC,mBAAqB,CAAC,CAACC,IAAM,IAAIC,SAAW,6CAA6C,CAACD,IAAM,yDAAyDC,SAAW,6CAA6C,CAACD,IAAM,sDAAsDC,SAAW,6CAA6C,CAACD,IAAM,+DAA+DC,SAAW,6CAA6C,CAACD,IAAM,8DAA8DC,SAAW,6CAA6C,CAACD,IAAM,+DAA+DC,SAAW,6CAA6C,CAACD,IAAM,uDAAuDC,SAAW,4ECA7wB,IAAMC,EAAa,kBAAqBJ,KAAaC,mBAAmBI,KAAI,SAAAC,GAAC,OAAIA,EAAEH,YAAUI,KAAK,IAC5FC,EAAeR,KAAaC,mBAAmBI,KAAI,SAAAC,GAAC,OAAIA,EAAEJ,OAEhEM,EAAYC,QACV,0FACA,wEACA,0HACA,6FACA,mKACA,oBACA,qBACA,eACA,qBACA,cACA,eAIFT,KAAKU,iBAAiB,WAAW,SAAAC,GAG9BA,EAAcC,UAEbC,OAAOC,KAAKV,GAAYW,MAAK,SAAAC,GAAK,OAAIA,EAAMC,OAAOT,UAOvDR,KAAKU,iBAAiB,YAAY,SAAAC,GAC7BA,EAAcC,UAEfC,OACGK,OAEAH,MAAK,SAAAG,GAAI,OACRC,QAAQC,IACNF,EAEGG,QAAO,SAAAC,GAAG,OAAIA,IAAQlB,KAEtBC,KAAI,SAAAiB,GAAG,OAAIT,OAAOU,OAAOD,cAQtCtB,KAAKU,iBAAiB,SAAS,SAASC,GAGrCA,EAAca,YAEbX,OAAOY,MAAOd,EAAce,SAASX,MAAK,SAAAY,GAExC,OAAIA,GAGFC,MAAOjB,EAAce,SAElBX,MAAK,SAAAY,GAAQ,OACZd,OAAOC,KAAKV,GAETW,MAAK,SAAAC,GAIJ,OADAA,EAAMa,IAAKlB,EAAce,QAASC,EAASG,SACpCH,QAGZI,OAAM,WAAA,OAAMC,QAAQC,IAAI","sources":["./precache-manifest.js","./src/serviceWorker.ts"],"sourcesContent":[null,"const CACHE_NAME = 'frsource-cache-' + (self as any).__precacheManifest.map(p => p.revision).join('');\nconst urlsToCache = (self as any).__precacheManifest.map(p => p.url)\n;\nurlsToCache.unshift(\n  'https://www.frsource.org/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js',\n  'https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap',\n  'https://fonts.googleapis.com/css2?family=Ubuntu+Mono&display=swap&text=%C4%99%C4%85%C5%9B%C5%82%C5%BC%C5%BA%C4%87%C5%84',\n  'https://fonts.gstatic.com/s/sharetechmono/v10/J7aHnp1uDWRBEqV98dVQztYldFcLowEFA87Heg.woff2',\n  'https://fonts.gstatic.com/l/font?kit=KFOjCneDtsqEr0keqCMhbBc4AMP6lbphGhjRbyploJUb8yKJ6s5XI8tJUsXjXaqyFuCyVwJ8jVcmwuy8_GNlbhL8K6FntdY&skey=8c1feb82f3a61020&v=v10',\n  '/site.webmanifest',\n  '/browserconfig.xml',\n  '/favicon.ico',\n  '/favicon-32x32.png',\n  '/robots.txt',\n  '/humans.txt',\n);\n\n// Listen for the install event, which fires when the service worker is installing\nself.addEventListener('install', event => {\n  // Ensures the install event doesn't complete until after the cache promise resolves\n  // This is so we don't move on to other events until the critical initial cache is done\n  (event as any).waitUntil(\n    // Open a named cache, then add all the specified URLs to it\n    caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))\n  );\n});\n\n// Listen for the activate event, which is fired after installation\n// Activate is when the service worker actually takes over from the previous\n// version, which is a good time to clean up old caches\nself.addEventListener('activate', event => {\n    (event as any).waitUntil(\n    // Get the keys of all the old caches\n    caches\n      .keys()\n      // Ensure we don't resolve until all the promises do (i.e. each key has been deleted)\n      .then(keys =>\n        Promise.all(\n          keys\n            // Remove any cache that not matches the current cache name\n            .filter(key => key !== CACHE_NAME)\n            // Map over the array of old cache names and delete them all\n            .map(key => caches.delete(key))\n        )\n      )\n  );\n});\n\n// Listen for browser fetch events. These fire any time the browser tries to load\n// any outside resources\nself.addEventListener('fetch', function(event) {\n  // This lets us control the response\n  // We pass in a promise that resolves with a response object\n  (event as any).respondWith(\n    // Check whether we have a matching response for this request in our cache\n    caches.match((event as any).request).then(response => {\n      // It's in the cache! Serve the response straight from there\n      if (response) return response;\n      // If it's not in the cache we make a fetch request for the resource\n      return (\n        fetch((event as any).request)\n          // Then we open our cache\n          .then(response => \n            caches.open(CACHE_NAME)\n              // Then we put the request into the cache, so we have it offline next time\n              .then(cache => {\n                // We have to clone the response as response streams can only be read once\n                // This way we can put one copy in the cache and return the other to the browser\n                cache.put((event as any).request, response.clone());\n                return response;\n              })\n          )\n          .catch(() => console.log('Fetch failed, sorry.'))\n      );\n    })\n  );\n});"],"names":["self","__precacheManifest","url","revision","CACHE_NAME","map","p","join","urlsToCache","unshift","addEventListener","event","waitUntil","caches","open","then","cache","addAll","keys","Promise","all","filter","key","delete","respondWith","match","request","response","fetch","put","clone","catch","console","log"],"version":3,"file":"serviceWorker.js.map"}