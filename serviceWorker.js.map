{"mappings":"mmCAAAA,KAAKC,mBAAmB,CAAC,CAACC,IAAM,IAAIC,SAAW,6BAA6B,CAACD,IAAM,yCAAyCC,SAAW,6BAA6B,CAACD,IAAM,sCAAsCC,SAAW,6BAA6B,CAACD,IAAM,kDAAkDC,SAAW,6BAA6B,CAACD,IAAM,8CAA8CC,SAAW,6BAA6B,CAACD,IAAM,sCAAsCC,SAAW,6BAA6B,CAACD,IAAM,+CAA+CC,SAAW,6BAA6B,CAACD,IAAM,uCAAuCC,SAAW,+CCAnqB,MAAMC,WAAa,kBAAqBJ,KAAaC,mBAAmBI,KAAIC,GAAKA,EAAEH,WAAUI,KAAK,IAC5FC,YAAeR,KAAaC,mBAAmBI,KAAIC,GAAKA,EAAEJ,MAEhEM,YAAYC,QACV,0FACA,oEACA,0HACA,oBACA,qBACA,eACA,qBACA,cACA,eAIFT,KAAKU,iBAAiB,WAAWC,IAG9BA,EAAcC,UAEbC,OAAOC,KAAKV,YAAYW,MAAKC,GAASA,EAAMC,OAAOT,mBAOvDR,KAAKU,iBAAiB,YAAYC,IAC7BA,EAAcC,UAEfC,OACGK,OAEAH,MAAKG,GACJC,QAAQC,IACNF,EAEGG,QAAOC,GAAOA,IAAQlB,aAEtBC,KAAIiB,GAAOT,OAAOU,OAAOD,YAQtCtB,KAAKU,iBAAiB,SAAS,SAASC,GAGrCA,EAAca,YAEbX,OAAOY,MAAOd,EAAce,SAASX,MAAKY,GAEpCA,GAGFC,MAAOjB,EAAce,SAElBX,MAAKc,GACJhB,OAAOC,KAAKV,YAETW,MAAKC,IAGJA,EAAMc,IAAKnB,EAAce,QAASG,EAASE,SACpCF,OAGZG,OAAK,IAAOC,QAAQC,IAAI","sources":["runtime-7cc9e055de74d8b9.js","src/serviceWorker.ts"],"sourcesContent":["self.__precacheManifest=[{\"url\":\"/\",\"revision\":\"f0ddf3f5\"},{\"url\":\"/favicon.6262c1fb.svg\",\"revision\":\"6262c1fb\"},{\"url\":\"/index.b3397075.js\",\"revision\":\"b3397075\"},{\"url\":\"/ResizeObserver.es.30c3b14c.js\",\"revision\":\"30c3b14c\"},{\"url\":\"/contactDialog.2d8b3df3.js\",\"revision\":\"2d8b3df3\"},{\"url\":\"/tpl.1f9b693a.html\",\"revision\":\"1f9b693a\"},{\"url\":\"/contactDialog.26593260.css\",\"revision\":\"26593260\"},{\"url\":\"/index.2c36aee7.css\",\"revision\":\"2c36aee7\"}]","const CACHE_NAME = 'frsource-cache-' + (self as any).__precacheManifest.map(p => p.revision).join('');\nconst urlsToCache = (self as any).__precacheManifest.map(p => p.url)\n;\nurlsToCache.unshift(\n  'https://www.frsource.org/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js',\n  'https://fonts.googleapis.com/css2?family=Inconsolata&display=swap',\n  'https://fonts.gstatic.com/s/inconsolata/v20/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WR32kXWdycuJDA.woff',\n  '/site.webmanifest',\n  '/browserconfig.xml',\n  '/favicon.ico',\n  '/favicon-32x32.png',\n  '/robots.txt',\n  '/humans.txt',\n);\n\n// Listen for the install event, which fires when the service worker is installing\nself.addEventListener('install', event => {\n  // Ensures the install event doesn't complete until after the cache promise resolves\n  // This is so we don't move on to other events until the critical initial cache is done\n  (event as any).waitUntil(\n    // Open a named cache, then add all the specified URLs to it\n    caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))\n  );\n});\n\n// Listen for the activate event, which is fired after installation\n// Activate is when the service worker actually takes over from the previous\n// version, which is a good time to clean up old caches\nself.addEventListener('activate', event => {\n    (event as any).waitUntil(\n    // Get the keys of all the old caches\n    caches\n      .keys()\n      // Ensure we don't resolve until all the promises do (i.e. each key has been deleted)\n      .then(keys =>\n        Promise.all(\n          keys\n            // Remove any cache that not matches the current cache name\n            .filter(key => key !== CACHE_NAME)\n            // Map over the array of old cache names and delete them all\n            .map(key => caches.delete(key))\n        )\n      )\n  );\n});\n\n// Listen for browser fetch events. These fire any time the browser tries to load\n// any outside resources\nself.addEventListener('fetch', function(event) {\n  // This lets us control the response\n  // We pass in a promise that resolves with a response object\n  (event as any).respondWith(\n    // Check whether we have a matching response for this request in our cache\n    caches.match((event as any).request).then(response => {\n      // It's in the cache! Serve the response straight from there\n      if (response) return response;\n      // If it's not in the cache we make a fetch request for the resource\n      return (\n        fetch((event as any).request)\n          // Then we open our cache\n          .then(response => \n            caches.open(CACHE_NAME)\n              // Then we put the request into the cache, so we have it offline next time\n              .then(cache => {\n                // We have to clone the response as response streams can only be read once\n                // This way we can put one copy in the cache and return the other to the browser\n                cache.put((event as any).request, response.clone());\n                return response;\n              })\n          )\n          .catch(() => console.log('Fetch failed, sorry.'))\n      );\n    })\n  );\n});"],"names":["self","__precacheManifest","url","revision","CACHE_NAME","map","p","join","urlsToCache","unshift","addEventListener","event","waitUntil","caches","open","then","cache","addAll","keys","Promise","all","filter","key","delete","respondWith","match","request","response1","fetch","response","put","clone","catch","console","log"],"version":3,"file":"serviceWorker.js.map"}