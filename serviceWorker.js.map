{"mappings":"qmCAAAA,KAAKC,mBAAkB,MAAQ,aAAe,kCAAoC,kDAAoD,kCAAoC,+CAAiD,kCAAoC,2DAA6D,kCAAoC,uDAAyD,kCAAoC,wDAA0D,kCAAoC,gDAAkD,+CCA7kB,MAAMC,WAAU,kBAAwBF,KAAaC,mBAAmBE,KAAIC,GAAKA,EAAEC,WAAUC,KAAI,IAC3FC,YAAeP,KAAaC,mBAAmBE,KAAIC,GAAKA,EAAEI,MAEhED,YAAYE,QAAO,0FACwE,oEACtB,0HACsD,oBACtG,qBACC,eACN,qBACM,cACP,eAKfT,KAAKU,iBAAgB,WAAYC,IAG9BA,EAAcC,UAEbC,OAAOC,KAAKZ,YAAYa,MAAKC,GAASA,EAAMC,OAAOV,mBAOvDP,KAAKU,iBAAgB,YAAaC,IAC7BA,EAAcC,UAEfC,OACGK,OAEAH,MAAKG,GACJC,QAAQC,IACNF,EAEGG,QAAOC,GAAOA,IAAQpB,aAEtBC,KAAImB,GAAOT,OAAOU,OAAOD,YAQtCtB,KAAKU,iBAAgB,SAAQ,SAAWC,GAGrCA,EAAca,YAEbX,OAAOY,MAAOd,EAAce,SAASX,MAAKY,GAEpCA,GAGFC,MAAOjB,EAAce,SAElBX,MAAKc,GACJhB,OAAOC,KAAKZ,YAETa,MAAKC,IAGJA,EAAMc,IAAKnB,EAAce,QAASG,EAASE,SACpCF,OAGZG,OAAK,IAAOC,QAAQC,IAAG","sources":["runtime-c8718e276f97c723.js","src/serviceWorker.ts"],"sourcesContent":["self.__precacheManifest=[{\"url\":\"/\",\"revision\":\"7b1b596a\"},{\"url\":\"/favicon.6262c1fb.svg\",\"revision\":\"6262c1fb\"},{\"url\":\"/index.6d8d4ba8.js\",\"revision\":\"6d8d4ba8\"},{\"url\":\"/ResizeObserver.es.2ce0de47.js\",\"revision\":\"2ce0de47\"},{\"url\":\"/contactDialog.12590b0b.js\",\"revision\":\"12590b0b\"},{\"url\":\"/contactDialog.2ea68ce0.css\",\"revision\":\"2ea68ce0\"},{\"url\":\"/index.dc3190f9.css\",\"revision\":\"dc3190f9\"}]","const CACHE_NAME = 'frsource-cache-' + (self as any).__precacheManifest.map(p => p.revision).join('');\nconst urlsToCache = (self as any).__precacheManifest.map(p => p.url)\n;\nurlsToCache.unshift(\n  'https://www.frsource.org/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js',\n  'https://fonts.googleapis.com/css2?family=Inconsolata&display=swap',\n  'https://fonts.gstatic.com/s/inconsolata/v20/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8WR32kXWdycuJDA.woff',\n  '/site.webmanifest',\n  '/browserconfig.xml',\n  '/favicon.ico',\n  '/favicon-32x32.png',\n  '/robots.txt',\n  '/humans.txt',\n);\n\n// Listen for the install event, which fires when the service worker is installing\nself.addEventListener('install', event => {\n  // Ensures the install event doesn't complete until after the cache promise resolves\n  // This is so we don't move on to other events until the critical initial cache is done\n  (event as any).waitUntil(\n    // Open a named cache, then add all the specified URLs to it\n    caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache))\n  );\n});\n\n// Listen for the activate event, which is fired after installation\n// Activate is when the service worker actually takes over from the previous\n// version, which is a good time to clean up old caches\nself.addEventListener('activate', event => {\n    (event as any).waitUntil(\n    // Get the keys of all the old caches\n    caches\n      .keys()\n      // Ensure we don't resolve until all the promises do (i.e. each key has been deleted)\n      .then(keys =>\n        Promise.all(\n          keys\n            // Remove any cache that not matches the current cache name\n            .filter(key => key !== CACHE_NAME)\n            // Map over the array of old cache names and delete them all\n            .map(key => caches.delete(key))\n        )\n      )\n  );\n});\n\n// Listen for browser fetch events. These fire any time the browser tries to load\n// any outside resources\nself.addEventListener('fetch', function(event) {\n  // This lets us control the response\n  // We pass in a promise that resolves with a response object\n  (event as any).respondWith(\n    // Check whether we have a matching response for this request in our cache\n    caches.match((event as any).request).then(response => {\n      // It's in the cache! Serve the response straight from there\n      if (response) return response;\n      // If it's not in the cache we make a fetch request for the resource\n      return (\n        fetch((event as any).request)\n          // Then we open our cache\n          .then(response => \n            caches.open(CACHE_NAME)\n              // Then we put the request into the cache, so we have it offline next time\n              .then(cache => {\n                // We have to clone the response as response streams can only be read once\n                // This way we can put one copy in the cache and return the other to the browser\n                cache.put((event as any).request, response.clone());\n                return response;\n              })\n          )\n          .catch(() => console.log('Fetch failed, sorry.'))\n      );\n    })\n  );\n});"],"names":["self","__precacheManifest","CACHE_NAME","map","p","revision","join","urlsToCache","url","unshift","addEventListener","event","waitUntil","caches","open","then","cache","addAll","keys","Promise","all","filter","key","delete","respondWith","match","request","response","fetch","response1","put","clone","catch","console","log"],"version":3,"file":"serviceWorker.js.map"}